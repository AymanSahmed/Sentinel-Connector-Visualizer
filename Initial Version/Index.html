<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentinel Artifact Visualizer</title>
    <!-- Tailwind CSS for modern aesthetics and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js library for graph visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f7f7; }
        .container { max-width: 1400px; }
        #visualization-container {
            border: 2px solid #e5e7eb;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }
        /* Custom styles for the graph nodes to ensure visibility */
        .node-group rect { transition: all 0.2s ease-in-out; }
        .node-group:hover rect {
            transform: scale(1.03); /* Slightly reduced scale for stability */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        /* Clearer link path styling */
        .graph-link { 
            stroke-dasharray: none; 
            transition: stroke-width 0.2s, stroke-opacity 0.2s;
        }
        .graph-link:hover { 
            stroke-width: 3; 
            stroke-opacity: 1.0; 
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="container mx-auto space-y-6">
        <header class="text-center">
            <h1 class="text-3xl font-bold text-gray-800">Sentinel Solution Dependency Visualizer</h1>
            <p id="status" class="mt-2 text-sm text-gray-600">Enter GitHub details and click "Load Solutions" to begin.</p>
        </header>

        <!-- Control Panel -->
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 grid grid-cols-1 md:grid-cols-6 gap-4 items-end">
            <!-- Repo Input -->
            <div class="md:col-span-2">
                <label for="repoInput" class="block text-sm font-medium text-gray-700">GitHub Repo (Owner/Repo)</label>
                <input type="text" id="repoInput" value="Azure/Azure-Sentinel" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border">
            </div>
            <!-- Branch Input -->
            <div>
                <label for="branchInput" class="block text-sm font-medium text-gray-700">Branch</label>
                <input type="text" id="branchInput" value="master" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border">
            </div>
            <!-- PAT Input -->
            <div>
                <label for="tokenInput" class="block text-sm font-medium text-gray-700">GitHub PAT (Optional)</label>
                <input type="password" id="tokenInput" placeholder="Token" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border">
            </div>
            <!-- Buttons -->
            <button id="btnLoad" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-xl shadow-md transition duration-150">Load Solutions</button>
            <button id="btnViz" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-xl shadow-md transition duration-150">Visualize</button>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- Solution Selector and Metadata Panel -->
            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                <h3 class="text-lg font-semibold mb-3 border-b pb-2">Select Solution</h3>
                <select id="solutionSelect" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border">
                    <option value="">(Load solutions first)</option>
                </select>

                <!-- Connector Selector -->
                <h3 class="text-lg font-semibold mt-6 mb-3 border-b pb-2">Select Connector</h3>
                <select id="connectorSelect" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border" disabled>
                    <option value="">(Visualize a solution first)</option>
                </select>

                <!-- Connector Details Panel -->
                <div id="connectorDetails" class="mt-6 p-4 bg-white rounded-xl border border-gray-200 shadow-inner">
                    <p class="text-sm text-gray-500">Select a connector above to view its technical classification (e.g., CCF vs. Legacy HTTP).</p>
                </div>
                
                <!-- General Solution Metadata Panel -->
                <div id="solutionMeta" class="mt-6 p-4 bg-gray-50 rounded-lg">
                    <p class="text-sm text-gray-500">General Solution metadata will appear here after visualization.</p>
                </div>
            </div>

            <!-- Visualization Area -->
            <div id="visualization-container" class="lg:col-span-3 h-[900px] overflow-hidden relative">
                <div id="tooltip" class="absolute z-10 p-2 bg-gray-800 text-white rounded-md shadow-xl text-sm pointer-events-none opacity-0 transition duration-150"></div>
                <svg id="viz" class="w-full h-full"></svg>
            </div>
        </div>

    </div>

    <!-- The complete application logic -->
    <script>
        'use strict';

/* ===========================
   Helpers & shared utilities
   =========================== */

const qs = (s) => document.querySelector(s);
// Global state to store fetched connectors for the dropdown
let currentConnectors = []; 
let currentMaintemplateMeta = {};
let currentNodes = []; // New global state for graph nodes

function setStatus(msg, isError = false) {
  const el = qs('#status');
  if (!el) return;
  el.textContent = msg;
  el.style.color = isError ? '#b91c1c' : '#6b7280';
}

function ghHeaders() {
  const tokenInput = qs('#tokenInput');
  // Safely check for tokenInput element
  const t = tokenInput ? (tokenInput.value || '').trim() : ''; 
  return t ? { Authorization: `token ${t}` } : {};
}

// Simple utility to find tables mentioned in a KQL query
function extractTablesFromQuery(query) {
    if (!query) return [];
    // A simple regex to catch common table names or 'im<schema>' function calls
    // Also includes _CL suffix for Custom Logs
    const tableRegex = /\b([A-Za-z0-9_]+_CL)\b|\b([A-Za-z]+Events?)\b|\b(im[A-Z][A-Za-z0-9_]*)\b/g;
    const matches = Array.from(query.matchAll(tableRegex)).map(match => match.find(m => m !== undefined && m !== match[0]));
    return Array.from(new Set(matches)).filter(t => t && t.length > 2);
}

// Map common stream names to default tables
const STREAM_TO_TABLE = {
  'microsoft-syslog': 'Syslog',
  'microsoft-windowsevent': 'WindowsEvents',
  'microsoft-commonsecuritylog': 'CommonSecurityLog',
  'microsoft-azurefirewall': 'AzureDiagnostics',
  'microsoft-perf': 'Perf',
};

function mapStreamToTable(streamName) {
  if (!streamName) return null;
  const key = String(streamName).toLowerCase().trim();
  if (STREAM_TO_TABLE[key]) return STREAM_TO_TABLE[key];
  if (key.startsWith('custom-')) {
    const suffix = key.replace(/^custom-/, '').replace(/[^a-z0-9]/gi, '');
    if (suffix) return `${suffix}_CL`;
  }
  return null;
}

/* ===========================
   1) Load Solutions into dropdown
   =========================== */
async function loadSolutions() {
  try {
    const repoStr = (qs('#repoInput').value || '').trim();
    if (!repoStr.includes('/')) {
      setStatus('Repo must be like Owner/Repo', true); 
      return;
    }
    const [owner, repo] = repoStr.split('/');
    // Use the Branch input for the path
    const branch = qs('#branchInput').value.trim(); 
    const url = `https://api.github.com/repos/${owner}/${repo}/contents/Solutions?ref=${encodeURIComponent(branch)}`;
    setStatus('Loading Solutions ...');

    const res = await fetch(url, { headers: ghHeaders() });
    if (!res.ok) {
      let detail = '';
      try { detail = await res.text(); } catch {}
      throw new Error(`GitHub API error ${res.status}: ${res.statusText}. Check repo name, branch, and GitHub token (if used).`);
    }

    const list = await res.json();
    const dirs = (list || [])
      .filter((x) => x.type === 'dir')
      .map((x) => x.name)
      .sort((a, b) => a.localeCompare(b));

    const sel = qs('#solutionSelect');
    sel.innerHTML = '';
    if (dirs.length === 0) {
      sel.innerHTML = '<option value="">(no solutions found)</option>';
      setStatus('No Solutions found under /Solutions', true);
      return;
    }

    for (const name of dirs) {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    }
    setStatus(`Loaded ${dirs.length} solutions. Select one and click Visualize.`);
  } catch (err) {
    console.error(err);
    setStatus(err.message || 'Error loading solutions', true);
  }
}

/* ===========================
   2) Enumerate JSON files recursively in a solution
   =========================== */
async function listJsonPathsForSolution(owner, repo, branch, solutionName) {
  setStatus(`Resolving branch ${branch} tree ...`);
  const bres = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/branches/${encodeURIComponent(branch)}`,
    { headers: ghHeaders() }
  );
  if (!bres.ok) {
    let detail = '';
    try { detail = await bres.text(); } catch {}
    throw new Error(`Branch API error ${bres.status}: ${detail || bres.statusText}`);
  }
  const b = await bres.json();
  const treeSha = b?.commit?.commit?.tree?.sha;
  if (!treeSha) throw new Error('Could not resolve branch tree SHA.');

  setStatus('Listing repository tree (recursive) ...');
  const tres = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/git/trees/${treeSha}?recursive=1`,
    { headers: ghHeaders() }
  );
  if (!tres.ok) {
    let detail = '';
    try { detail = await tres.text(); } catch {}
    throw new Error(`Trees API error ${tres.status}: ${detail || tres.statusText}`);
  }

  const t = await tres.json();
  const prefix = `Solutions/${solutionName}/`;
  const paths = (t.tree || [])
    .filter((it) => it.type === 'blob' && it.path.startsWith(prefix) && it.path.toLowerCase().endsWith('.json'))
    .map((it) => it.path);

  return paths;
}

/* ===========================
   3) Classification & Enrichment
   =========================== */

/**
 * Determine ingestion mechanism and connection type based on JSON content.
 * This logic is updated to reflect the explicit kind checks provided by the user.
 */
function classifyMechanismAndType(jsonObj) {
  const text = JSON.stringify(jsonObj).toLowerCase();
  const ui = jsonObj?.properties?.connectorUiConfig || jsonObj?.properties?.connectorUiConfig;
  const kind = (jsonObj?.kind || jsonObj?.properties?.kind || '').toLowerCase();

  let connectionType = 'N/A';
  let mechanism = 'Unknown';
  
  // 1. Specific 'kind' checks for precise classification (CCF vs. Legacy)
  
  // CCF - API Polling (RestApiPoller is the modern kind, APIPolling is sometimes seen)
  if (kind === 'restapipoller' || kind === 'apipolling') {
      connectionType = 'Pull';
      mechanism = 'CCF (Codeless) - API Polling';
      return { connectionType, mechanism };
  } 
  
  // Legacy - Azure Functions / HTTP Data Collector API
  if (kind === 'azurefunction' || kind === 'datacollector') {
      connectionType = 'Push';
      mechanism = 'Azure Functions / HTTP Data Collector API';
      return { connectionType, mechanism };
  }
  
  // 2. Fallback to general classification logic
  
  // Check for general CCF/Codeless signals (e.g., UI config without specific kind or kind: customizable)
  if (ui || kind === 'customizable') {
    connectionType = 'Pull';
    mechanism = 'CCF (Codeless) - UI Driven';
    return { connectionType, mechanism };
  } 
  
  // Check for DCR/AMA/MMA signals (Data Collection Rules)
  const isDCR = text.includes('microsoft.insights/datacollectionrules') ||
          jsonObj?.properties?.dataSources || jsonObj?.dataSources || jsonObj?.dataFlows;
  
  if (isDCR) {
    const ds = jsonObj?.properties?.dataSources || jsonObj?.dataSources || {};
    const hasSyslog = !!ds.syslog || text.includes('syslog');
    const hasWindows = !!ds.windowsEvent || text.includes('windowsevent');
    mechanism = (hasSyslog || hasWindows) ? 'AMA/MMA Agent' : 'Logs Ingestion API';
    connectionType = 'Push'; 
    return { connectionType, mechanism };
  } 
  
  // Check for Logic Apps (text search)
  if (text.includes('logic app') || text.includes('workflows')) {
    connectionType = 'Pull';
    mechanism = 'Logic Apps';
    return { connectionType, mechanism };
  } 
  
  // Check for other custom code/legacy API interaction (text search fallback)
  if (text.includes('azure function') || text.includes('functionapp') || text.includes('data collector api') || text.includes('log analytics api')) {
    connectionType = 'Pull/Push';
    mechanism = 'Custom Code/Legacy API Interaction';
    return { connectionType, mechanism };
  }

  // Default to Service-to-Service if no other signal is present
  connectionType = 'Pull';
  mechanism = 'Service-to-Service';
  
  return { connectionType, mechanism };
}

// Extract connector name and data source
function extractConnectorName(jsonObj, fallbackName) {
  const ui = jsonObj?.properties?.connectorUiConfig || jsonObj?.properties?.connectorUIConfig;
  const title = ui?.title || ui?.displayName || jsonObj?.name;
  return (title || fallbackName || 'Unnamed Connector').trim();
}

function extractDataSource(jsonObj, filePath, solutionName) {
  const ui = jsonObj?.properties?.connectorUiConfig || jsonObj?.properties?.connectorUiConfig;
  const publisher = ui?.publisherName || ui?.publisher;
  if (publisher) return publisher.trim();
  if (solutionName) return solutionName.trim();
  const last = filePath?.split('/')?.pop()?.replace(/\.json$/i, '') || 'Unknown';
  return last;
}

// Pick tables from DCR by looking at streams and transformation KQL
function pickTablesFromDcr(dcrObj) {
  const out = new Set();
  const props = dcrObj?.properties || dcrObj;
  const dataFlows = props?.dataFlows || [];
  const transform = (df) => (df?.transformKql ? String(df.transformKql) : '');
  for (const df of dataFlows) {
    const streams = Array.isArray(df.streams) ? df.streams : [];
    for (const s of streams) {
      const tableGuess = mapStreamToTable(s);
      if (tableGuess) out.add(tableGuess);
    }
    const kql = transform(df).toLowerCase();
    // Look for 'into table <TableName>'
    const m = kql.match(/into\s+table\s+([a-z0-9_]+)/i);
    if (m && m[1]) out.add(m[1]);
  }
  return Array.from(out);
}

function pickStreamsFromDcr(dcrObj) {
  const out = new Set();
  const props = dcrObj?.properties || dcrObj;
  const dataFlows = props?.dataFlows || [];
  for (const df of dataFlows) {
    const streams = Array.isArray(df.streams) ? df.streams : [];
    streams.forEach((s) => out.add(s));
  }
  return Array.from(out);
}

// Maintemplate metadata extraction (Solution metadata)
async function extractMaintemplateMetadata(owner, repo, branch, solutionName, paths) {
  const maintemplatePath = 
    paths.find(p => /Package\/mainTemplate\.json$/i.test(p)) ||
    paths.find(p => /Maintemplate\.json$/i.test(p));

  if (!maintemplatePath) return null;

  const url = `https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(branch)}/${maintemplatePath}`;
  const res = await fetch(url, { headers: ghHeaders() });
  
  if (!res.ok) {
    console.warn(`Failed to fetch mainTemplate.json from ${url}. Status: ${res.status}`);
    return null;
  }
  
  let json;
  try { json = await res.json(); } catch { 
    console.warn('Failed to parse mainTemplate.json content.');
    return null; 
  }

  const findParamValue = (params, keys) => {
    if (!params) return '';
    for (const key of keys) {
      const param = Object.keys(params).find(k => k.toLowerCase() === key.toLowerCase());
      if (param && params[param]?.defaultValue) return String(params[param].defaultValue);
    }
    return '';
  };

  const params = json?.parameters;
  const metadata = {
    solutionName: findParamValue(params, ['SolutionName', 'solutionName']),
    publisher: findParamValue(params, ['Publisher', 'publisher']),
    contactEmail: findParamValue(params, ['ContactEmail', 'contactEmail']),
  };
  
  if (!metadata.solutionName) {
      metadata.solutionName = solutionName;
  }

  return metadata;
}

// Fetch and classify connectors and DCRs
async function fetchConnectorsAndDcrs(owner, repo, branch, paths, solutionName) {
  const baseRaw = `https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(branch)}/`;
  const connectors = [];
  const dcrs = [];
  let filesProcessed = 0;

  // Pass 1: Collect DCRs
  for (const p of paths) {
    const url = baseRaw + p;
    const r = await fetch(url, { headers: ghHeaders() });
    if (!r.ok) continue;
    let json;
    try { json = await r.json(); } catch { continue; }
    filesProcessed++;

    const text = JSON.stringify(json).toLowerCase();
    const looksLikeDcr = text.includes('microsoft.insights/datacollectionrules') ||
                         json?.properties?.dataSources || json?.dataSources || json?.dataFlows;
    
    if (looksLikeDcr) {
      const dcrId = json?.name?.replace(/\[parameters\(['"](.*)['"]\)\]/g, '$1') || p.split('/').pop().replace(/\.json$/i, '');
      
      dcrs.push({
        id: dcrId, // Unique ID for deduplication
        name: json?.properties?.displayName || dcrId,
        streams: pickStreamsFromDcr(json),
        tables: pickTablesFromDcr(json),
        raw: json,
        path: p,
      });
    }
  }

  const finalDcrs = Array.from(new Map(dcrs.map(d => [d.id, d])).values());

  // Pass 2: Collect Connectors and link them to DCRs
  for (const p of paths) {
    const url = baseRaw + p;
    const r = await fetch(url, { headers: ghHeaders() });
    if (!r.ok) continue;
    let json;
    try { json = await r.json(); } catch { continue; }

    const text = JSON.stringify(json).toLowerCase();
    const ui = json?.properties?.connectorUiConfig || json?.properties?.connectorUiConfig;
    const hasConnectorSignals = ui || text.includes('dataconnector');

    if (hasConnectorSignals) {
      const mechanismInfo = classifyMechanismAndType(json);
      const name = extractConnectorName(json, p.split('/').pop());
      const dataSource = extractDataSource(json, p, solutionName);
      
      // Attempt to link connector to DCRs by checking if the DCR name/ID is present in the connector's template
      const linkedDcrIds = finalDcrs
        .filter(dcr => text.includes(dcr.id.toLowerCase()) || text.includes(dcr.name.toLowerCase()))
        .map(dcr => dcr.id);

      connectors.push({
        name,
        dataSource,
        connectionType: mechanismInfo.connectionType,
        mechanism: mechanismInfo.mechanism,
        path: p,
        raw: json,
        linkedDcrIds: linkedDcrIds, // Store DCR IDs for graph building
        // Use the DCR's tables as the connector's output tables if directly linked
        outputTables: linkedDcrIds.flatMap(id => finalDcrs.find(d => d.id === id)?.tables || [])
      });
    }
  }

  return { connectors, dcrs: finalDcrs, filesProcessed };
}


// Collect artifacts (Hunting, Workbooks, Analytics Rules)
async function collectQueryArtifacts(owner, repo, branch, paths) {
  const baseRaw = `https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(branch)}/`;
  const artifacts = { hunting: [], workbooks: [], analyticsRules: [] };

  const looksLike = {
    hunting: (p) => /\/hunting( queries)?\//i.test(p),
    workbook: (p) => /\/workbooks?\//i.test(p),
    analyticsRule: (p) => /\/analytics\s?rules?\//i.test(p) || /\/alertrules\//i.test(p),
  };

  for (const p of paths) {
    if (!looksLike.hunting(p) && !looksLike.workbook(p) && !looksLike.analyticsRule(p)) continue;

    const r = await fetch(baseRaw + p, { headers: ghHeaders() });
    if (!r.ok) continue;
    let json;
    try { json = await r.json(); } catch { continue; }

    const name = json?.properties?.displayName || json?.properties?.title || json?.name || p.split('/').pop();
    const query = json?.properties?.query || json?.query || json?.properties?.kql || '';
    
    let finalQuery = query;
    if (looksLike.workbook(p) && json?.properties?.content) {
        const contentStr = JSON.stringify(json.properties.content);
        // Simple regex to extract KQL from query properties within the workbook structure
        const kqlMatches = contentStr.match(/\"query\":\s*\"(.*?)\"/g);
        if (kqlMatches) {
            finalQuery = kqlMatches.map(m => m.replace(/\"query\":\s*\"(.*?)\"/, '$1')).join('\n');
        }
    }
    
    if (typeof finalQuery === 'string' && finalQuery.trim()) {
      const tables = extractTablesFromQuery(finalQuery);
      const artifact = { name, query: finalQuery, tables, path: p };

      if (looksLike.hunting(p)) {
        artifacts.hunting.push(artifact);
      } else if (looksLike.workbook(p)) {
        artifacts.workbooks.push(artifact);
      } else if (looksLike.analyticsRule(p)) {
        artifacts.analyticsRules.push(artifact);
      }
    }
  }
  return artifacts;
}

// Extract ASIM/im tokens from query (kept for enrichment)
function extractNormalizationTokens(query) {
  const tokens = new Set();
  (query.match(/\bASIM[_A-Za-z0-9]+/g) || []).forEach(t => tokens.add(t));
  (query.match(/\bim[A-Z][A-Za-z0-9_]*/g) || []).forEach(t => tokens.add(t));
  return Array.from(tokens);
}

// Enrich connectors with hunting and normalization metadata
function enrichConnectors(connectors, huntingQueries) {
  for (const c of connectors) {
    const hits = [];
    const norms = new Set();
    
    // Use the connector's detected output tables to link to hunting queries
    const tablesToCheck = Array.from(new Set(c.outputTables || []));
    
    for (const h of huntingQueries) {
      let isHit = false;
      for(const table of tablesToCheck) {
        // Simple check: does the hunting query string contain the table name?
        if (h.query.includes(table)) {
          isHit = true;
          break;
        }
      }

      if (isHit) {
        hits.push({ name: h.name, path: h.path });
        extractNormalizationTokens(h.query).forEach(tok => norms.add(tok));
      }
    }
    c.hunting = hits;
    c.huntingCount = hits.length;
    c.normalization = Array.from(norms);
  }
}

/* ===========================
   4) Display Metadata
   =========================== */

function displayMaintemplateInfo(meta) {
    const metaDiv = qs('#solutionMeta');
    
    if (meta && meta.solutionName) {
        metaDiv.innerHTML = `
            <h3 class="text-lg font-semibold border-b pb-1 mb-2">General Solution Metadata</h3>
            <ul class="text-sm space-y-0.5">
                <li><b>Solution Name:</b> ${meta.solutionName || 'N/A'}</li>
                <li><b>Contact E-mail:</b> ${meta.contactEmail || 'N/A'}</li>
                <li><b>Publisher:</b> ${meta.publisher || 'N/A'}</li>
            </ul>
        `;
    } else {
        metaDiv.innerHTML = `<span class="text-red-700 text-sm p-2">Solution metadata (Maintemplate.json) could not be loaded or is incomplete.</span>`;
    }
}

function displayConnectorInfo(connectorName) {
    const detailsDiv = qs('#connectorDetails');
    const connector = currentConnectors.find(c => c.name === connectorName);
    
    if (connector) {
        // Use color coding based on CCF vs. Legacy for clear identification
        const isCcf = connector.mechanism.includes('CCF (Codeless)');
        const colorClass = isCcf ? 'bg-green-100 text-green-800' : 'bg-orange-100 text-orange-800';
        
        detailsDiv.innerHTML = `
            <h3 class="text-lg font-semibold border-b pb-1 mb-2 text-blue-600">Connector Classification</h3>
            <ul class="text-sm space-y-2">
                <li class="p-2 rounded-lg font-bold ${colorClass}">
                    <span class="text-base">${connector.mechanism}</span>
                </li>
                <li class="p-2 rounded-lg bg-gray-100 text-gray-800">
                    <b>Data Flow:</b> ${connector.connectionType}
                </li>
                <li class="p-2 rounded-lg bg-gray-100 text-gray-800">
                    <b>Data Source:</b> ${connector.dataSource}
                </li>
                <li class="p-2 rounded-lg bg-gray-100 text-gray-800">
                    <b>Query Artifacts Linked:</b> ${connector.huntingCount || 0}
                </li>
            </ul>
        `;
        
        // **NEW VISUAL ENHANCEMENT**: Highlight the selected node
        highlightNode(connectorName);
        
    } else {
        detailsDiv.innerHTML = `
            <p class="text-sm text-gray-500">Select a connector above to view its technical classification (e.g., CCF vs. Legacy HTTP).</p>
        `;
        // **NEW VISUAL ENHANCEMENT**: Clear highlight
        highlightNode(null);
    }
}

/* ===========================
   5) Build graph from all artifacts 
   =========================== */
function buildGraph(allArtifacts) {
  const { connectors, dcrs, workbooks, analyticsRules } = allArtifacts;
  const nodes = [];
  const links = [];
  const map = Object.create(null); // Map for deduplication

  const addNode = (id, type, meta) => {
    if (!id) return null;
    const k = String(id);
    if (!map[k]) {
      map[k] = { id: k, type, meta: { ...meta } };
      nodes.push(map[k]);
    } else {
      // Merge metadata for existing nodes (e.g., if a table is linked multiple times)
      map[k].meta = { ...(map[k].meta || {}), ...(meta || {}) }; 
    }
    return map[k];
  };

  const addLink = (s, t, type) => {
    if (!s || !t) return;
    const sId = typeof s === 'string' ? s : s.id;
    const tId = typeof t === 'string' ? t : t.id;

    // Use a unique ID pair for link deduplication
    const linkKey = `${sId}->${tId}`;
    const isDuplicate = links.some(l => 
        (l.source === sId && l.target === tId) || (l.source.id === sId && l.target.id === tId));

    if (!isDuplicate) {
        links.push({ source: sId, target: tId, type });
    }
  };
  
  // 1. DCR Normalization Pre-processing: Map DCR ID to its associated normalization schemas (via connector link)
  const dcrNormalizationMap = new Map();
  for (const c of connectors) {
      if (c.normalization && c.normalization.length > 0) {
          for (const dcrId of c.linkedDcrIds || []) {
              dcrNormalizationMap.set(dcrId, c.normalization);
          }
      }
  }

  // Filter out DCRs without detected tables and create a map for quick lookup
  const filteredDcrs = dcrs.filter(d => d.tables && d.tables.length > 0);
  const dcrMap = new Map(filteredDcrs.map(d => [d.id, d]));
  
  // 2. CREATE DCR and Target Table/Normalization Nodes (Layer 3 & 4)
  dcrMap.forEach(d => {
    // DCR Node (Layer 3)
    addNode(d.id, 'dependency', { 
        name: d.name, 
        tables: d.tables,
        tableCount: d.tables.length
    });
    
    // Link DCR to Target Tables (Endpoint - Layer 4)
    for (const table of d.tables || []) {
      addNode(table, 'table', {}); 
      addLink(d.id, table, 'writes-to-table'); // DCR -> Target Table
    }

    // Link DCR to Normalization Schemas (Endpoint - Layer 4)
    const normalizationTokens = dcrNormalizationMap.get(d.id);
    if (normalizationTokens && normalizationTokens.length > 0) {
        // Use the primary normalization token or the first table name for the node ID
        const normId = `Norm Schema (${normalizationTokens[0].split('_')[0]})`; 
        addNode(normId, 'normalization', { tokens: normalizationTokens });
        addLink(d.id, normId, 'normalizes-to'); // DCR -> Normalization Schema
    }
  });

  // 3. CREATE Connector and Source Nodes (Layer 2 & 1)
  for (const c of connectors) {
    // Connector node (Layer 2)
    addNode(c.name, 'connector', {
      dataSource: c.dataSource,
      mechanism: c.mechanism,
      connectionType: c.connectionType,
      huntingCount: c.huntingCount || 0,
    });

    // Source node (Layer 1)
    addNode(c.dataSource, 'source', {});
    
    // Links: Source -> Connector (Layer 1 -> 2)
    addLink(c.dataSource, c.name, 'ingests'); 

    // Links: Connector -> DCR (Layer 2 -> 3)
    for (const dcrId of c.linkedDcrIds || []) {
      if (dcrMap.has(dcrId)) { 
          addLink(c.name, dcrId, 'connector-to-dcr');
      }
    }

    // Fallback: If no DCR is explicitly linked, but the connector has output tables (e.g., legacy HTTP API)
    if ((c.linkedDcrIds?.length === 0) && c.outputTables?.length > 0) {
        // This is a direct table output scenario, typical of legacy connectors
        for (const table of c.outputTables) {
            addNode(table, 'table', {});
            addLink(c.name, table, 'writes-to-table-direct');
        }
    }
  }
  
  // 4. Add Workbook and Analytics Rule Flow (Layer 5) 

  // Workbooks (Layer 5)
  for (const wb of workbooks) {
    const wbId = `WB: ${wb.name}`;
    addNode(wbId, 'workbook', { query: wb.query });
    
    // Link Tables/Norm Schemas to Workbook (Layer 4 -> 5)
    for (const table of wb.tables) {
        // Check if the table is a valid node (i.e., created by a DCR or direct link)
        if (map[table]) {
            addLink(table, wbId, 'queries'); 
        }
    }
  }

  // Analytics Rules (Layer 5)
  for (const ar of analyticsRules) {
    const arId = `AR: ${ar.name}`;
    addNode(arId, 'analyticrule', { query: ar.query });

    // Link Tables/Norm Schemas to Rule (Layer 4 -> 5)
    for (const table of ar.tables) {
        // Check if the table is a valid node (i.e., created by a DCR or direct link)
        if (map[table]) {
            addLink(table, arId, 'queries');
        }
    }
  }

  return { nodes, links };
}

/* ===========================
   4) Display Metadata
   =========================== */

function displayMaintemplateInfo(meta) {
    const metaDiv = qs('#solutionMeta');
    
    if (meta && meta.solutionName) {
        metaDiv.innerHTML = `
            <h3 class="text-lg font-semibold border-b pb-1 mb-2">General Solution Metadata</h3>
            <ul class="text-sm space-y-0.5">
                <li><b>Solution Name:</b> ${meta.solutionName || 'N/A'}</li>
                <li><b>Contact E-mail:</b> ${meta.contactEmail || 'N/A'}</li>
                <li><b>Publisher:</b> ${meta.publisher || 'N/A'}</li>
            </ul>
        `;
    } else {
        metaDiv.innerHTML = `<span class="text-red-700 text-sm p-2">Solution metadata (Maintemplate.json) could not be loaded or is incomplete.</span>`;
    }
}

function displayConnectorInfo(connectorName) {
    const detailsDiv = qs('#connectorDetails');
    const connector = currentConnectors.find(c => c.name === connectorName);
    
    if (connector) {
        // Use color coding based on CCF vs. Legacy for clear identification
        const isCcf = connector.mechanism.includes('CCF (Codeless)');
        const colorClass = isCcf ? 'bg-green-100 text-green-800' : 'bg-orange-100 text-orange-800';
        
        detailsDiv.innerHTML = `
            <h3 class="text-lg font-semibold border-b pb-1 mb-2 text-blue-600">Connector Classification</h3>
            <ul class="text-sm space-y-2">
                <li class="p-2 rounded-lg font-bold ${colorClass}">
                    <span class="text-base">${connector.mechanism}</span>
                </li>
                <li class="p-2 rounded-lg bg-gray-100 text-gray-800">
                    <b>Data Flow:</b> ${connector.connectionType}
                </li>
                <li class="p-2 rounded-lg bg-gray-100 text-gray-800">
                    <b>Data Source:</b> ${connector.dataSource}
                </li>
                <li class="p-2 rounded-lg bg-gray-100 text-gray-800">
                    <b>Query Artifacts Linked:</b> ${connector.huntingCount || 0}
                </li>
            </ul>
        `;
        
        // Highlight the selected node
        highlightNode(connectorName);
        
    } else {
        detailsDiv.innerHTML = `
            <p class="text-sm text-gray-500">Select a connector above to view its technical classification (e.g., CCF vs. Legacy HTTP).</p>
        `;
        // Clear highlight
        highlightNode(null);
    }
}

/* ===========================
   6) Render the graph
   =========================== */
   
// Tooltip setup
function setupTooltip(svg) {
    const tooltip = d3.select('#tooltip');
    
    const showTooltip = (event, d) => {
        let content = `<b>Type: ${d.type}</b><hr class='my-1'>`;
        
        if (d.type === 'connector') {
            content += `<b>Name:</b> ${d.id}<br>`;
            content += `<b>Mechanism:</b> ${d.meta.mechanism}<br>`;
            content += `<b>Artifacts:</b> ${d.meta.huntingCount}<br>`;
        } else if (d.type === 'table') {
            content += `<b>Table:</b> ${d.id}<br>`;
        } else if (d.type === 'dependency') {
            content += `<b>DCR:</b> ${d.meta.name}<br>`;
            content += `<b>Outputs:</b> ${d.meta.tableCount} tables<br>`;
        } else if (d.type === 'normalization') {
            content += `<b>Tokens:</b> ${d.meta.tokens.join(', ')}<br>`;
        } else if (d.type.includes('rule') || d.type.includes('workbook')) {
            content += `<b>Name:</b> ${d.id.split(': ')[1] || d.id}<br>`;
        } else if (d.type === 'source') {
            content += `<b>Platform:</b> ${d.id}<br>`;
        }
        
        tooltip.html(content)
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 28) + 'px')
            .style('opacity', 1);
    };

    const hideTooltip = () => {
        tooltip.style('opacity', 0);
    };

    return { showTooltip, hideTooltip };
}


// Dynamic highlighting
function highlightNode(nodeId) {
    const svg = d3.select('svg');
    const allNodes = svg.selectAll('.node-group');
    const allLinks = svg.selectAll('.graph-link');

    if (!nodeId) {
        // Clear all highlights
        allNodes.select('rect')
            .style('filter', 'drop-shadow(3px 3px 2px rgba(0,0,0,0.2))')
            .attr('opacity', 1.0)
            .attr('stroke', '#333')
            .attr('stroke-width', 1.5);
        allLinks.attr('stroke-opacity', 0.8).attr('stroke-width', 2);
        return;
    }
    
    const selectedNode = currentNodes.find(n => n.id === nodeId);
    if (!selectedNode) return;
    
    // Dim all nodes and links initially
    allNodes.select('rect')
        .style('filter', 'drop-shadow(3px 3px 2px rgba(0,0,0,0.1))')
        .attr('opacity', 0.4)
        .attr('stroke-width', 0.5);
    allLinks.attr('stroke-opacity', 0.1).attr('stroke-width', 1);
    
    const highlightPath = new Set([nodeId]);
    const incomingLinks = new Set();
    const outgoingLinks = new Set();

    // Traverse the graph to find connected nodes (Simple 2-level traversal for clarity)
    // Step 1: Find direct connections
    allLinks.data().forEach(l => {
        const linkKey = l.source.id + '->' + l.target.id;
        if (l.source.id === nodeId) {
            highlightPath.add(l.target.id);
            outgoingLinks.add(linkKey);
        } else if (l.target.id === nodeId) {
            highlightPath.add(l.source.id);
            incomingLinks.add(linkKey);
        }
    });
    
    // Step 2: Find connections to the directly connected nodes (2-hops)
    allLinks.data().forEach(l => {
        const linkKey = l.source.id + '->' + l.target.id;
        if (highlightPath.has(l.source.id) && l.source.id !== nodeId) {
            highlightPath.add(l.target.id);
            outgoingLinks.add(linkKey);
        } else if (highlightPath.has(l.target.id) && l.target.id !== nodeId) {
             highlightPath.add(l.source.id);
             incomingLinks.add(linkKey);
        }
    });

    // Highlight the path nodes
    allNodes.filter(d => highlightPath.has(d.id))
        .select('rect')
        .attr('opacity', 1.0)
        .attr('stroke', '#000000')
        .attr('stroke-width', 3)
        .style('filter', 'drop-shadow(3px 3px 5px rgba(0,0,0,0.5))');
        
    // Highlight the links in the path
    allLinks.attr('stroke-opacity', d => {
        const linkKey = d.source.id + '->' + d.target.id;
        return (incomingLinks.has(linkKey) || outgoingLinks.has(linkKey)) ? 1.0 : 0.1;
    })
    .attr('stroke-width', d => {
        const linkKey = d.source.id + '->' + d.target.id;
        return (incomingLinks.has(linkKey) || outgoingLinks.has(linkKey)) ? 3 : 1;
    });
}
   
function renderGraph(svg, data) {
  const { nodes, links } = data;
  currentNodes = nodes; // Store nodes for highlighting
  svg.selectAll('*').remove();

  // Define SVG size and viewBox
  svg
    .attr('width', 1400)
    .attr('height', 900)
    .attr('viewBox', '0 0 1400 900');

  const width = 1400;
  const height = 900;
  
  // Setup Tooltip
  const { showTooltip, hideTooltip } = setupTooltip(svg);

  // Color mapping by connector type/mechanism 
  const typeColor = {
    // Connector Mechanisms (Solution Type)
    'CCF (Codeless) - API Polling': '#4caf50', 
    'CCF (Codeless) - UI Driven': '#81c784', 
    'Azure Functions / HTTP Data Collector API': '#ff9800', 
    'AMA/MMA Agent': '#ffccbc', 
    'Logic Apps': '#c5e1a5', 
    'Logs Ingestion API': '#ffe082', 
    'Custom Code/Legacy API Interaction': '#bbdefb', 
    'Service-to-Service': '#cfd8dc', 

    // Functional Layers
    'source': '#4dd0e1', 
    'connector': '#26a69a', 
    'dependency': '#81c784', 

    // Endpoints / Data Layer
    'table': '#ff8a65', 
    'normalization': '#9575cd', 

    // Analysis Layer
    'workbook': '#ffb74d', 
    'analyticrule': '#e57373', 
  };

  function getNodeColor(d) {
    if (d.type === 'connector') {
      const mech = d.meta?.mechanism || '';
      return typeColor[mech] || typeColor[d.type] || '#eeeeee';
    }
    return typeColor[d.type] || '#eeeeee';
  }
  
  // Helper to determine text color (simple based on luminance)
  function getTextColor(hex) {
    if (!hex) return '#333';
    // Ensure hex is in 6-digit format
    if (hex.length === 4) {
      hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    let r = parseInt(hex.substring(1, 3), 16);
    let g = parseInt(hex.substring(3, 5), 16);
    let b = parseInt(hex.substring(5, 7), 16);
    // Calculate relative luminance
    let luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? '#222' : '#fff';
  }

  function wrapText(text, maxChars) {
    const words = text.split(' ');
    const lines = [];
    let line = '';
    words.forEach(word => {
      if ((line + word).length > maxChars) {
        lines.push(line.trim());
        line = word + ' ';
      } else {
        line += word + ' ';
      }
    });
    if (line.trim()) lines.push(line.trim());
    return lines;
  }

  // Sort nodes by layer for better initial layout
  nodes.sort((a, b) => {
    const order = { source: 0, connector: 1, dependency: 2, table: 3, normalization: 3, workbook: 4, analyticrule: 4 };
    return (order[a.type] ?? 99) - (order[b.type] ?? 99);
  });

  const g = svg.append('g');
  // Enable zoom/pan
  svg.call(d3.zoom().scaleExtent([0.5, 2]).on('zoom', (e) => g.attr('transform', e.transform)))
    .on('dblclick.zoom', null);

  // Define Arrow Marker
  svg.append('defs').append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 20)
    .attr('refY', 0)
    .attr('markerWidth', 8)
    .attr('markerHeight', 8)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#333');

  // --- D3 FORCES FOR STABLE CASCADED LAYOUT ---
  const sim = d3.forceSimulation(nodes)
    // Decreased forces for faster convergence and stability
    .force('link', d3.forceLink(links).id((d) => d.id).distance(120).strength(0.4))
    .force('charge', d3.forceManyBody().strength(-80)) 
    .force('collide', d3.forceCollide(70))

    // Enforce X-positions for each layer (Very high strength for clear layers)
    .force('layerX', d3.forceX().x(d => {
        switch (d.type) {
            case 'source': return width * 0.10;         // Layer 1
            case 'connector': return width * 0.25;      // Layer 2
            case 'dependency': return width * 0.40;     // Layer 3
            case 'table': 
            case 'normalization': return width * 0.60;  // Layer 4
            case 'workbook': 
            case 'analyticrule': return width * 0.85;   // Layer 5
            default: return width / 2;
        }
    }).strength(3.0)) // Increased strength to prevent X-movement

    .force('centerY', d3.forceY(height / 2).strength(0.6)); 
  
  // *** NEW: Run simulation until stabilization and then stop it ***
  sim.stop();
  // Run enough iterations for a stable layout
  for (let i = 0; i < 200; ++i) sim.tick();

  const link = g.append('g')
    .attr('stroke', '#4b5563')
    .attr('stroke-opacity', 0.8)
    .selectAll('line')
    .data(links)
    .enter().append('line')
    .attr('class', 'graph-link')
    .attr('stroke-width', 2)
    .attr('marker-end', 'url(#arrow)')
    // Apply initial positions statically
    .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
    .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

  const rectWidth = 220;
  const rectHeight = 110;
  const rectRx = 12;
  const maxCharsPerLine = 28;
  const maxLines = 5;

  const nodeGroup = g.append('g')
    .selectAll('g')
    .data(nodes)
    .enter().append('g')
    .attr('class', 'node-group')
    // Apply initial positions statically
    .attr('transform', d => `translate(${d.x},${d.y})`)
    
    // Add tooltip handlers
    .on('mouseover', showTooltip)
    .on('mouseout', hideTooltip)
    
    // Add click handler to select and highlight
    .on('click', function(event, d) {
        if (d.type === 'connector') {
            qs('#connectorSelect').value = d.id;
            displayConnectorInfo(d.id);
        } else {
            // If another node type is clicked, just highlight it temporarily
            highlightNode(d.id);
        }
    })
    // *** NEW: Custom Drag Handler for Static Movement ***
    .call(
      d3.drag()
        .on('start', (e, d) => {
          // Set fixed coordinates on start (required for D3 drag)
          d.fx = d.x;
          d.fy = d.y;
        })
        .on('drag', (e, d) => {
          // Update fixed coordinates
          d.fx = e.x;
          d.fy = e.y;
          
          // Manually update the node's position
          d3.select(e.sourceEvent.currentTarget)
              .attr('transform', `translate(${e.x},${e.y})`);
          
          // Manually update associated link coordinates
          link.filter(l => l.source.id === d.id)
              .attr('x1', e.x).attr('y1', e.y);
          link.filter(l => l.target.id === d.id)
              .attr('x2', e.x).attr('y2', e.y);
              
          // Update the data structure's current position (for future drags)
          d.x = e.x;
          d.y = e.y;
        })
        .on('end', (e, d) => {
          // Clear fixed coordinates, but since simulation is stopped, the node stays put
          d.fx = null;
          d.fy = null;
        })
    );

  nodeGroup.append('rect')
    .attr('width', rectWidth)
    .attr('height', rectHeight)
    .attr('x', -rectWidth / 2)
    .attr('y', -rectHeight / 2)
    .attr('rx', rectRx)
    .attr('fill', d => getNodeColor(d))
    .attr('stroke', '#333')
    .attr('stroke-width', 1.5)
    .style('filter', 'drop-shadow(3px 3px 2px rgba(0,0,0,0.2))');

  // Title uses more detailed description
  nodeGroup.append('title').text(d => {
    if (d.type === 'connector') return `Connector: ${d.id}\nMechanism: ${d.meta.mechanism}`;
    if (d.type === 'table') return `Target Table: ${d.id}`;
    if (d.type === 'analyticrule') return `Analytic Rule: ${d.id.replace('AR: ', '')}`;
    if (d.type === 'workbook') return `Workbook: ${d.id.replace('WB: ', '')}`;
    return d.id;
  });

  // --- Node Text Generation ---
  nodeGroup.each(function (d) {
    const g = d3.select(this);
    const nodeColor = getNodeColor(d);
    const textColor = getTextColor(nodeColor); // Dynamic text color
    let lines = [];
    
    // More concise labels and better hierarchy
    if (d.type === 'connector') {
      const m = d.meta || {};
      lines.push(`CONNECTOR: ${d.id}`);
      lines.push(`Source: ${m.dataSource || 'N/A'}`);
      lines.push(`Mechanism: ${m.mechanism.replace('CCF (Codeless) - ', '').replace('Azure Functions / ', '')}`); 
      lines.push(`Flow: ${m.connectionType || 'N/A'}`);
      lines.push(`Artifacts: ${m.huntingCount} Queries`);
    } else if (d.type === 'dependency') {
      // DCR Node content
      const m = d.meta || {};
      lines.push(`DCR (Data Collection Rule)`); 
      lines.push(`Name: ${m.name || d.id}`); 
      lines.push(`Role: Transformation/Mapping`);
      lines.push(`Outputs: ${m.tableCount} Tables`); 
    } else if (d.type === 'source') {
      lines.push(`DATA SOURCE`);
      lines.push(`Platform: ${d.id}`);
    } else if (d.type === 'table') { 
      lines.push(`TARGET TABLE`);
      lines.push(`Name: ${d.id}`);
    } else if (d.type === 'normalization') { 
        const m = d.meta || {};
        lines.push(`NORMALIZATION SCHEMA`);
        lines.push(`Type: ${d.id.replace('Norm Schema (', '').replace(')', '')}`);
        lines.push(`Tokens: ${m.tokens.slice(0, 2).join(', ')}${m.tokens.length > 2 ? '...' : ''}`);
    } else if (d.type === 'workbook') {
        lines.push(`ANALYSIS: WORKBOOK`);
        lines.push(`Name: ${d.id.replace(/^WB: /, '')}`);
    } else if (d.type === 'analyticrule') {
        lines.push(`ANALYSIS: RULE`);
        lines.push(`Name: ${d.id.replace(/^AR: /, '')}`);
    } else {
      lines.push(d.id);
    }

    let wrappedLines = lines.flatMap(line => wrapText(line, maxCharsPerLine));
    if (wrappedLines.length > maxLines) {
      wrappedLines = wrappedLines.slice(0, maxLines);
      wrappedLines[maxLines - 1] += ' ...';
    }

    const text = g.append('text')
      .attr('font-size', 14)
      .attr('font-family', 'Inter, sans-serif')
      .attr('fill', textColor) // Use dynamic text color
      .attr('text-anchor', 'start')
      .attr('x', -rectWidth / 2 + 10)
      .attr('y', -rectHeight / 2 + 20);

    wrappedLines.forEach((line, i) => {
      // Highlight the first line (title)
      const isTitle = i === 0;
      text.append('tspan')
        .attr('x', -rectWidth / 2 + 10)
        .attr('dy', i === 0 ? 0 : 18)
        .attr('font-weight', isTitle ? 700 : 400)
        .text(line);
    });
  });

  // *** REMOVED: sim.on('tick') and window.onresize listeners ***
  // Layout is now stable and statically applied.
}

/* ===========================
   7) Visualization flow
   =========================== */
async function visualizeSolution() {
  try {
    const repoStr = qs('#repoInput').value.trim();
    const branch = qs('#branchInput').value.trim();
    const sol = qs('#solutionSelect').value.trim();

    if (!repoStr.includes('/') || !sol) {
      setStatus('Please enter a valid GitHub repo and select a Solution.', true);
      return;
    }

    const [owner, repo] = repoStr.split('/');
    
    setStatus(`Listing all JSON paths in "${sol}" on branch "${branch}"...`);
    const paths = await listJsonPathsForSolution(owner, repo, branch, sol);
    if (paths.length === 0) {
      setStatus('No JSON files found in this solution. Check the repo and branch.', true);
      return;
    }

    setStatus(`Fetching & classifying connectors and DCRs in "${sol}" ...`);
    const { connectors, dcrs, filesProcessed } = await fetchConnectorsAndDcrs(owner, repo, branch, paths, sol);
    
    setStatus(`Collecting Workbooks, Analytics Rules, and Hunting Queries...`);
    const { hunting: huntingQueries, workbooks, analyticsRules } = await collectQueryArtifacts(owner, repo, branch, paths);
    
    // Enrich connectors before deduplication for accurate feature count
    enrichConnectors(connectors, huntingQueries);

    const maintemplateMeta = await extractMaintemplateMetadata(owner, repo, branch, sol, paths);
    
    // Store general metadata globally
    currentMaintemplateMeta = maintemplateMeta;

    // Display general metadata
    displayMaintemplateInfo(currentMaintemplateMeta);
    
    // Deduplicate connectors by name (CRITICAL: ensures one node per unique connector name)
    const uniqueConnectors = Array.from(new Map(connectors.map(c => [c.name, c])).values());
    
    // Store unique connectors globally and populate the new dropdown
    currentConnectors = uniqueConnectors;
    const connSel = qs('#connectorSelect');
    connSel.innerHTML = '<option value="">-- Select a specific Connector --</option>';
    connSel.disabled = false;
    
    for (const c of uniqueConnectors) {
        const opt = document.createElement('option');
        opt.value = c.name;
        opt.textContent = c.name;
        connSel.appendChild(opt);
    }
    // Reset connector details panel
    displayConnectorInfo(null);


    const allArtifacts = { connectors: uniqueConnectors, dcrs, workbooks, analyticsRules };
    
    // Build graph with all artifacts
    const { nodes, links } = buildGraph(allArtifacts);
    const svg = d3.select('svg');
    renderGraph(svg, { nodes, links });
    setStatus(`Done. Files processed: ${filesProcessed}. Rendered ${nodes.length} nodes / ${links.length} links.`, false);
  } catch (err) {
    console.error(err);
    setStatus(err.message || 'Error', true);
  }
}

/* ===========================
   8) Button bindings
   ===========================*/
document.addEventListener('DOMContentLoaded', () => {
  const btnLoad = qs('#btnLoad');
  const btnViz = qs('#btnViz');
  const connSel = qs('#connectorSelect');

  if (btnLoad) {
    btnLoad.addEventListener('click', loadSolutions);
  }

  if (btnViz) {
    btnViz.addEventListener('click', visualizeSolution);
  }
  
  if (connSel) {
    connSel.addEventListener('change', (e) => displayConnectorInfo(e.target.value));
  }

  // Set default repo for quick testing
  if (!qs('#repoInput').value) {
    qs('#repoInput').value = 'Azure/Azure-Sentinel'; 
  }
});
    </script>
</body>
</html>
