<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Sentinel Solution Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="description" content="Visualize Microsoft Sentinel solution artifacts, architecture, and dependencies." />
<style>
/* ==============================
   Sentinel Solution Visualizer
   Modernized Design System
   ============================== */
/* Core Theme Tokens */
:root {
  color-scheme: light dark;
  --bg:            #f8fafc;
  --bg-alt:        #f1f5f9;
  --panel:         #ffffff;
  --panel-alt:     #f9fafb;
  --panel-muted:   #eef2f7;
  --panel-border:  #e2e8f0;
  --panel-border-strong:#cbd5e1;

  --text:       #0f3e7a;
  --text-dim:   #475569;
  --text-muted: #64748b;
  --text-invert:#ffffff;

  --accent:        #2563eb;
  --accent-rgb:    37,99,235;
  --accent-strong: #1d4ed8;
  --accent-soft:   #e0ecff;

  --danger:     #dc2626;
  --warn:       #d97706;
  --success:    #059669;
  --info:       #0ea5e9;

  --badge-bg:   #eef2ff;
  --badge-text: #1d4ed8;

  --font-scale:1.15; 

  --grad-arch-default: linear-gradient(90deg,#334155,#475569);
  --grad-arch-ccf:     linear-gradient(90deg,#047857,#10b981);
  --grad-arch-http:    linear-gradient(90deg,#b45309,#f59e0b);
  --grad-arch-unknown: linear-gradient(90deg,#64748b,#475569);

  /* Elevation */
  --shadow-xs: 0 1px 2px rgba(0,0,0,.05);
  --shadow-sm: 0 2px 4px rgba(0,0,0,.08);
  --shadow-md: 0 4px 12px -2px rgba(0,0,0,.15);
  --shadow-lg: 0 8px 24px -4px rgba(0,0,0,.20);
  --shadow-glow-accent: 0 0 0 1px rgba(var(--accent-rgb),.15),0 0 0 6px rgba(var(--accent-rgb),.08);

  /* Radii */
  --radius-xs:4px;
  --radius-sm:6px;
  --radius:   10px;
  --radius-lg:14px;
  --radius-pill:999px;

  /* Spacing Scale */
  --space-1: .25rem;
  --space-2: .4rem;
  --space-3: .55rem;
  --space-4: .7rem;
  --space-5: .9rem;
  --space-6: 1.15rem;
  --space-7: 1.5rem;

  /* Typography */
  --font-sans: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

  --fs-xxs:.55rem;
  --fs-xs:.60rem;
  --fs-sm:.68rem;
  --fs-base:.75rem;
  --fs-md:.85rem;
  --fs-lg:1.0rem;
  --fs-xl:1.25rem;
  --fs-xxl:1.55rem;

  /* Transitions & Motion */
  --ease-out: cubic-bezier(.16,.7,.3,1);
  --ease-in: cubic-bezier(.7,.1,.9,.3);
  --transition-fast: 120ms var(--ease-out);
  --transition-medium: 240ms var(--ease-out);

  /* Layout / Misc */
  --border-width:1px;
  --focus-ring: 2px solid var(--accent);
  --focus-ring-outline: 2px solid #ffffff;
  --scrollbar-track: var(--panel);
  --scrollbar-thumb: #cbd5e1;
  --scrollbar-thumb-hover:#94a3b8;
}

.dark {
  --bg:#0f172a;
  --bg-alt:#14243d;
  --panel:#1e293b;
  --panel-alt:#253348;
  --panel-muted:#243140;
  --panel-border:#334155;
  --panel-border-strong:#475569;

  --text:#f1f5f9;
  --text-dim:#94a3b8;
  --text-muted:#64748b;
  --badge-bg:#1e293b;
  --badge-text:#60a5fa;

  --accent:#3b82f6;
  --accent-strong:#1d4ed8;
  --accent-soft:#1e3a8a;

  --scrollbar-track:#1e293b;
  --scrollbar-thumb:#475569;
  --scrollbar-thumb-hover:#64748b;
}

/* Global Reset / Base */
html,body {
  height:100%;
  margin:0;
  font-family:var(--font-sans);
  font-size:var(--fs-base);
  background:var(--bg);
  color:var(--text);
  -webkit-font-smoothing:antialiased;
  font-size: calc(var(--fs-base) * var(--font-scale));
  text-rendering:optimizeLegibility;
}

body {
  display:flex;
  flex-direction:column;
  gap:var(--space-6);
  padding:var(--space-6);
  line-height:1.35;
}

@media (max-width:860px){
  body { padding:var(--space-4); }
}

h1,h2,h3,h4,h5 { font-weight:600; margin:0; }
h1 {
  font-size:var(--fs-xxl);
  letter-spacing:-.5px;
  display:flex;
  align-items:center;
  gap:.6rem;
}

/* Panels */
.panel {
  background:var(--panel);
  border:var(--border-width) solid var(--panel-border);
  border-radius:var(--radius-lg);
  padding:var(--space-5);
  box-shadow:var(--shadow-sm);
  position:relative;
  transition:background var(--transition-medium),border-color var(--transition-fast), box-shadow var(--transition-fast);
  backdrop-filter:saturate(140%) blur(2px);
}

.panel:hover {
  box-shadow:var(--shadow-md);
}

.panel:has(.panel-header + .skeleton){
  min-height:88px;
}

.panel-header {
  font-size:var(--fs-xxs);
  letter-spacing:.08em;
  font-weight:600;
  text-transform:uppercase;
  color:var(--text-dim);
  display:flex;
  align-items:center;
  gap:.4rem;
  user-select:none;
}

/* Badge */
.badge {
  display:inline-flex;
  align-items:center;
  gap:.25rem;
  background:var(--badge-bg);
  color:var(--badge-text);
  padding:2px 8px;
  border-radius:var(--radius-pill);
  font-size:var(--fs-xxs);
  font-weight:600;
  letter-spacing:.5px;
  line-height:1;
  box-shadow:var(--shadow-xs) inset;
  border:1px solid rgba(0,0,0,.05);
}

/* Inputs & Controls */
.input,
select.input,
textarea.input {
  appearance:none;
  -webkit-appearance:none;
  background:var(--panel);
  border:1px solid var(--panel-border);
  border-radius:var(--radius-sm);
  padding:6px 10px;
  font-size:var(--fs-sm);
  font-family:inherit;
  color:var(--text);
  width:100%;
  box-sizing:border-box;
  line-height:1.25;
  transition:border-color var(--transition-fast), background var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast);
}

.input:focus,
select.input:focus,
textarea.input:focus {
  outline:0;
  box-shadow:var(--shadow-glow-accent);
  border-color:var(--accent);
}

.input[disabled],
.input:disabled {
  opacity:.55;
  cursor:not-allowed;
  background:var(--panel-muted);
  color:var(--text-muted);
}

select.input {
  background:
    var(--panel)
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' stroke='%23475869' stroke-width='1.7' stroke-linecap='round' stroke-linejoin='round' fill='none'><polyline points='3 5 7 9 11 5'/></svg>")
    no-repeat right 10px center / 14px;
  padding-right:36px;
  cursor:pointer;
}

.dark select.input {
  background:
    var(--panel)
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' stroke='%2394a3b8' stroke-width='1.7' stroke-linecap='round' stroke-linejoin='round' fill='none'><polyline points='3 5 7 9 11 5'/></svg>")
    no-repeat right 10px center / 14px;
}

select.input option,
select.input optgroup {
  background:var(--panel);
  color:var(--text);
}

.dark select.input option,
.dark select.input optgroup {
  background:var(--panel);
  color:var(--text);
}

/* Dedicated Solution select override */
#solutionSelect {
  font-weight:600;
  letter-spacing:.03em;
}

/* Toggle / small inline label */
.toggle {
  display:inline-flex;
  align-items:center;
  gap:.4rem;
  font-size:var(--fs-xs);
  font-weight:500;
  color:var(--text-dim);
  white-space:nowrap;
}

/* Buttons */
.btn,
.btn-muted,
.btn-outline,
.btn-ghost,
.btn-danger {
  --btn-bg:var(--accent);
  --btn-color:#fff;
  --btn-border:var(--accent);
  --btn-shadow:var(--shadow-xs);
  appearance:none;
  border-radius:var(--radius-sm);
  border:1px solid var(--btn-border);
  background:var(--btn-bg);
  color:var(--btn-color);
  font-size:var(--fs-sm);
  font-weight:600;
  letter-spacing:.02em;
  padding:7px 16px;
  display:inline-flex;
  align-items:center;
  gap:.45rem;
  cursor:pointer;
  line-height:1.1;
  user-select:none;
  transition:background var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast), border-color var(--transition-fast), color var(--transition-fast);
  position:relative;
}

.btn:hover {
  background:var(--accent-strong);
  box-shadow:var(--shadow-sm);
}

.btn:active {
  transform:translateY(1px);
}

.btn-muted {
  --btn-bg:var(--panel-muted);
  --btn-color:var(--text-dim);
  --btn-border:var(--panel-border);
}

.btn-muted:hover {
  background:var(--panel-border);
  color:var(--text);
}

.dark .btn-muted:hover {
  background:var(--panel-alt);
  color:var(--text);
}

.btn-outline {
  --btn-bg:transparent;
  --btn-color:var(--accent);
  --btn-border:var(--accent);
}

.btn-outline:hover {
  background:rgba(var(--accent-rgb),.07);
  box-shadow:var(--shadow-xs);
}

.btn-ghost {
  --btn-bg:transparent;
  --btn-color:var(--text-dim);
  --btn-border:transparent;
  padding:6px 10px;
}

.btn-ghost:hover {
  background:var(--panel-muted);
  color:var(--text);
}

.btn-danger {
  --btn-bg:var(--danger);
  --btn-border:var(--danger);
}

.btn-danger:hover {
  background:#b91c1c;
}

.btn:focus-visible,
.btn-muted:focus-visible,
.btn-outline:focus-visible,
.btn-ghost:focus-visible,
.btn-danger:focus-visible {
  outline:0;
  box-shadow:var(--shadow-glow-accent);
}

/* Pill variant utility */
.btn-pill { border-radius:var(--radius-pill); }

/* Table */
table.artifact-table {
  border-collapse:separate;
  width:100%;
  font-size:var(--fs-xs);
  border-spacing:0 4px;
}

table.artifact-table thead th {
  background:var(--panel-muted);
  color:var(--text-dim);
  font-weight:600;
  font-size:var(--fs-xxs);
  padding:6px 8px;
  text-align:left;
  position:sticky;
  top:0;
  z-index:2;
  border-bottom:1px solid var(--panel-border);
  cursor:pointer;
  letter-spacing:.05em;
}

table.artifact-table tbody td {
  background:var(--panel-alt);
  border:1px solid var(--panel-border);
  padding:6px 8px;
  vertical-align:top;
  transition:background var(--transition-fast), color var(--transition-fast);
}

table.artifact-table tbody tr {
  border-radius:var(--radius-sm);
}

table.artifact-table tbody tr:hover td {
  background:var(--panel);
}

.dark table.artifact-table tbody td {
  background:#223147;
}

.dark table.artifact-table tbody tr:hover td {
  background:var(--panel);
}

/* Scrollbars (WebKit + Firefox) */
* {
  scrollbar-width:thin;
  scrollbar-color:var(--scrollbar-thumb) var(--scrollbar-track);
}

*::-webkit-scrollbar {
  width:10px;
  height:10px;
}
*::-webkit-scrollbar-track {
  background:var(--scrollbar-track);
}
*::-webkit-scrollbar-thumb {
  background:var(--scrollbar-thumb);
  border-radius:10px;
  border:2px solid var(--scrollbar-track);
}
*::-webkit-scrollbar-thumb:hover {
  background:var(--scrollbar-thumb-hover);
}

/* Tooltip */
#tooltip {
  pointer-events:none;
  z-index:60;
  min-width:220px;
  max-width:440px;
  background:#0f172a;
  color:#fff;
  padding:8px 10px;
  border-radius:var(--radius-sm);
  box-shadow:var(--shadow-md);
  font-size:var(--fs-xs);
  line-height:1.15rem;
  border:1px solid rgba(255,255,255,.08);
  backdrop-filter:blur(4px);
  transition:opacity var(--transition-fast), transform var(--transition-fast);
  transform:translateY(4px);
}

#tooltip.show {
  opacity:1!important;
  transform:translateY(0);
}

/* Graph styling (D3) */
#viz { font:10px var(--font-sans); }

.graph-link {
  transition:stroke-width .18s var(--ease-out), stroke-opacity .25s var(--ease-out);
}

.node-group rect {
  transition:filter .25s var(--ease-out), stroke-width .2s var(--ease-out), transform .25s var(--ease-out);
  transform-origin:center;
}

.node-group:hover rect {
  filter:brightness(1.08);
  transform:translateY(-2px);
}

.edge-label {
  font-size:var(--fs-xxs);
  fill:var(--text-dim);
  pointer-events:none;
  user-select:none;
}

/* Architecture Highlight Badge */
.arch-highlight {
  display:inline-flex;
  align-items:center;
  gap:.55rem;
  font-size:1.1rem;
  font-weight:700;
  padding:10px 18px;
  border-radius:var(--radius-pill);
  background:var(--grad-arch-default);
  color:#fff;
  letter-spacing:.5px;
  box-shadow:0 2px 8px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.15);
  position:relative;
  isolation:isolate;
  overflow:hidden;
  cursor:default;
  transition:transform var(--transition-medium), box-shadow var(--transition-medium);
}

.arch-highlight::after {
  content:"";
  position:absolute;
  inset:0;
  background:radial-gradient(circle at 25% 15%,rgba(255,255,255,.3),transparent 60%);
  opacity:.35;
  mix-blend-mode:overlay;
  pointer-events:none;
}

.arch-highlight.legacy {
  background:linear-gradient(90deg,#6d28d9,#9333ea);
}
.arch-highlight.unknown {
  background:linear-gradient(90deg,#64748b,#475569);
}

.arch-highlight:hover {
  transform:translateY(-2px);
  box-shadow:var(--shadow-lg);
}

.arch-highlight.ccf { background:var(--grad-arch-ccf); }
.arch-highlight.http { background:var(--grad-arch-http); }
.arch-highlight.unknown { background:var(--grad-arch-unknown); }

@media (prefers-reduced-motion:reduce){
  .arch-highlight { animation:none; transition:none; }
}

/* Disclaimer */
.disclaimer {
  position:fixed;
  left:14px;
  bottom:14px;
  max-width:360px;
  font-size:11px;
  line-height:1.35;
  font-weight:500;
  color:#b91c1c;
  background:rgba(255,255,255,.92);
  border:1px solid #fca5a5;
  padding:8px 10px;
  border-radius:var(--radius-sm);
  z-index:9999;
  backdrop-filter:blur(4px);
  box-shadow:var(--shadow-sm);
  transition:opacity var(--transition-medium);
}

.dark .disclaimer {
  background:rgba(31,41,55,.78);
  color:#fecaca;
  border-color:#b91c1c;
}

@media (max-width:640px){
  h1 { font-size:1.3rem; }
  .disclaimer { font-size:10px; max-width:78%; }
}

/* Evidence Modal */
#evidenceModalBackdrop {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.55);
  z-index:10000;
  backdrop-filter:blur(5px);
}

#evidenceModal {
  background:var(--panel);
  color:var(--text);
  width:clamp(500px,86%,1100px);
  max-height:82vh;
  border:1px solid var(--panel-border);
  border-radius:var(--radius-lg);
  box-shadow:var(--shadow-lg);
  display:flex;
  flex-direction:column;
  font-size:var(--fs-xs);
  overflow:hidden;
  position:relative;
  isolation:isolate;
}

#evidenceModal header {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:.8rem;
  padding:12px 18px;
  background:var(--panel-muted);
  font-weight:600;
  letter-spacing:.5px;
  border-bottom:1px solid var(--panel-border);
}

#evidenceModal .modal-body {
  padding:12px 18px;
  overflow:auto;
  line-height:1.05rem;
  scrollbar-gutter:stable;
}

#evidenceModal .filters {
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-bottom:10px;
  align-items:flex-end;
}

#evidenceModal button.small {
  background:var(--accent);
  color:#fff;
  border:none;
  border-radius:var(--radius-sm);
  padding:5px 10px;
  font-size:var(--fs-xxs);
  font-weight:600;
  cursor:pointer;
  line-height:1;
  letter-spacing:.03em;
  transition:background var(--transition-fast), transform var(--transition-fast);
}

#evidenceModal button.small.alt {
  background:var(--panel-muted);
  color:var(--text-dim);
}

#evidenceModal button.small:hover {
  filter:brightness(1.07);
}

#evidenceModal button.small:active {
  transform:translateY(1px);
}

.evidence-row {
  padding:6px 8px;
  border:1px solid var(--panel-border);
  border-radius:var(--radius-sm);
  background:var(--panel-alt);
  margin-bottom:6px;
  position:relative;
  transition:border-color var(--transition-fast), background var(--transition-fast);
}

.evidence-row:hover {
  background:var(--panel);
  border-color:var(--panel-border-strong);
}

.evidence-row.ccf { border-color:var(--success); }
.evidence-row.http { border-color:var(--warn); }

.evidence-row code {
  background:var(--panel-muted);
  padding:2px 5px;
  border-radius:var(--radius-xs);
  font-size:var(--fs-xxs);
  font-family:var(--font-mono);
  letter-spacing:.3px;
}

#evidenceModal .footer-actions {
  padding:10px 16px;
  background:var(--panel-muted);
  display:flex;
  justify-content:flex-end;
  gap:8px;
  border-top:1px solid var(--panel-border);
}

/* Loading Overlay */
#loadingOverlay {
  position:absolute;
  inset:0;
  display:none;
  background:rgba(255,255,255,.9);
  backdrop-filter:blur(4px);
  z-index:50;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  gap:1rem;
}

.dark #loadingOverlay {
  background:rgba(15,23,42,.82);
}

.spinner {
  width:52px;
  height:52px;
  border:5px solid var(--accent);
  border-top-color:transparent;
  border-radius:50%;
  animation:spin 1s linear infinite;
}

@keyframes spin { to { transform:rotate(360deg); } }

/* Zoom Buttons */
#viz + div button.btn-muted {
  width:42px;
  height:42px;
  font-size:1.05rem;
  font-weight:700;
  padding:0;
  justify-content:center;
}

/* Utility Classes */
.truncate {
  max-width:100%;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

.flex { display:flex; }
.flex-col { flex-direction:column; }
.flex-wrap { flex-wrap:wrap; }
.gap-xs { gap:var(--space-2); }
.gap-sm { gap:var(--space-3); }
.gap-md { gap:var(--space-4); }
.gap-lg { gap:var(--space-6); }

.text-dim { color:var(--text-dim); }
.text-muted { color:var(--text-muted); }
.text-accent { color:var(--accent); }

.border-accent { border-color:var(--accent)!important; }
.ring-accent { box-shadow:0 0 0 3px rgba(var(--accent-rgb),.35)!important; }

.hidden { display:none!important; }

/* Accessibility: reduced motion */
@media (prefers-reduced-motion:reduce){
  * {
    animation-duration:.01ms!important;
    animation-iteration-count:1!important;
    transition:none!important;
    scroll-behavior:auto!important;
  }
}

/* Dark mode specific nuance overrides */
.dark .panel { box-shadow:var(--shadow-xs); }
.dark .panel:hover { box-shadow:var(--shadow-md); }
.dark .evidence-row { background:#243447; }
.dark .evidence-row:hover { background:#2e4259; }
.dark #tooltip { background:#1e293b; color:var(--text); border-color:#334155; }
.dark .input, .dark select.input { border-color:#475569; }
.dark .input:focus, .dark select.input:focus { box-shadow:0 0 0 1px #1d4ed8,0 0 0 4px rgba(29,78,216,.35); }

/* Force option colors explicitly (extra safety for some legacy engines) */
.dark #solutionSelect option { background:var(--panel)!important; color:var(--text)!important; }

/* End modern stylesheet */
</style>

</head>
<body class="p-4" style="padding:1.2rem;display:flex;flex-direction:column;gap:1.1rem;">

<div class="disclaimer">
  Heuristic tool: connector type (CCF vs HTTP), endpoints, flows, and architecture layers are best‑effort. Validate with official Sentinel documentation.
</div>

<header style="text-align:center;display:flex;flex-direction:column;gap:.4rem;">
  <h1>Sentinel Solution Visualizer</h1>
  <p id="status" style="margin:0;font-size:.75rem;color:var(--text-dim);">Ready.</p>
</header>

<section class="panel" style="padding:1.1rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;align-items:start;">
  <div>
    <label class="panel-header" style="display:block;margin-bottom:4px;">GitHub Repo</label>
    <input id="repoInput" class="input" value="Azure/Azure-Sentinel" />
  </div>
  <div>
    <label class="panel-header" style="display:block;margin-bottom:4px;">Branch</label>
    <input id="branchInput" class="input" value="master" />
  </div>
  <div>
    <label class="panel-header" style="display:block;margin-bottom:4px;">Solution</label>
    <select id="solutionSelect" class="input">
      <option value="">(Load solutions)</option>
    </select>
  </div>
  <div>
    <label class="panel-header" style="display:block;margin-bottom:4px;">GitHub PAT (optional)</label>
    <input id="tokenInput" class="input" type="password" placeholder="ghp_..." />
  </div>
  <div style="display:flex;flex-wrap:wrap;gap:.5rem;align-items:flex-end;">
    <button id="btnLoad" class="btn">Load Solutions</button>
    <button id="btnVisualize" class="btn">Visualize</button>
    <button id="btnReset" class="btn-muted">Reset</button>
    <button id="btnDark" class="btn-muted">Dark</button>
  </div>
  <div style="grid-column:1/-1;display:flex;flex-wrap:wrap;gap:.8rem;font-size:.63rem;align-items:center;">
    <label class="toggle"><input id="includeNonCore" type="checkbox" checked />Include Non-Core</label>
    <label class="toggle"><input id="showEdgeLabels" type="checkbox" />Edge Labels</label>
    <label class="toggle"><input id="degreeScaled" type="checkbox" />Scale by Degree</label>
    <div style="display:flex;align-items:center;gap:4px;">
      <span style="font-size:.55rem;font-weight:600;letter-spacing:.05em;">Layout:</span>
      <select id="layoutSelect" class="input" style="width:170px;font-size:.6rem;padding:4px 6px;">
        <option value="force">Force (banded)</option>
        <option value="radial">Radial Rings</option>
        <option value="grid">Grid by Type</option>
        <option value="architecture">Architecture (top-down)</option>
      </select>
    </div>
    <button id="btnExportJson" class="btn-muted" style="font-size:.6rem;">Export JSON</button>
    <button id="btnExportCsv" class="btn-muted" style="font-size:.6rem;">Export CSV</button>
    <button id="btnExportPng" class="btn-muted" style="font-size:.6rem;">Export PNG</button>
    <span id="rateLimit" style="margin-left:auto;color:var(--text-dim);"></span>
  </div>
</section>

<div style="display:grid;grid-template-columns:320px 1fr;gap:1.2rem;">
  <aside style="display:flex;flex-direction:column;gap:1rem;">
    <div class="panel" style="padding:1rem;display:flex;flex-direction:column;gap:.7rem;">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div class="panel-header">Filters & Search</div>
        <button id="resetFilters" class="btn-muted" style="font-size:.55rem;padding:4px 8px;">Reset</button>
      </div>
      <input id="nodeSearch" class="input" placeholder="Node search..." />
      <div id="filterTypes" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(130px,1fr));gap:.4rem;font-size:.6rem;"></div>
      <div style="display:flex;flex-wrap:wrap;gap:.4rem;">
        <button id="btnFit" class="btn-muted" style="flex:1;">Fit</button>
        <button id="btnRecenter" class="btn-muted" style="flex:1;">Recenter</button>
        <button id="btnClearHighlight" class="btn-muted" style="flex:1;">Clear</button>
      </div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div class="panel-header" style="margin-bottom:.4rem;">Solution Meta</div>
      <div id="solutionMeta" style="font-size:.63rem;line-height:1.05rem;"></div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div class="panel-header" style="margin-bottom:.4rem;">Design Overview</div>
      <div id="designOverview" style="font-size:.63rem;line-height:1.05rem;">(Visualize to populate.)</div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div class="panel-header" style="margin-bottom:.4rem;">Selected Node</div>
      <div id="artifactMeta" style="font-size:.63rem;line-height:1.05rem;">Select a node.</div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div class="panel-header" style="margin-bottom:.4rem;">Logic & Wizard Analysis</div>
      <div id="logicPanel" style="font-size:.63rem;line-height:1.05rem;">(Pending)</div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div class="panel-header" style="margin-bottom:.4rem;">Legend</div>
      <div id="legend" style="font-size:.6rem;display:grid;gap:.25rem;"></div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div class="panel-header" style="margin-bottom:.4rem;">Diagnostics</div>
      <div id="log" style="font-size:.55rem;font-family:monospace;max-height:160px;overflow:auto;line-height:1.05rem;"></div>
    </div>
  </aside>

  <main style="display:flex;flex-direction:column;gap:1.2rem;">
    <div class="panel" style="position:relative;height:900px;">
      <svg id="viz" style="width:100%;height:100%;"><g id="zoomLayer"></g></svg>
      <div id="tooltip" style="position:absolute;top:0;left:0;opacity:0;background:#0f172a;color:#fff;padding:6px 8px;border-radius:6px;box-shadow:0 4px 16px -4px rgba(0,0,0,.4);"></div>
      <div id="loadingOverlay" style="display:none;position:absolute;inset:0;background:rgba(255,255,255,.9);backdrop-filter:blur(3px);z-index:50;align-items:center;justify-content:center;flex-direction:column;gap:1rem;">
        <div style="width:46px;height:46px;border:4px solid var(--accent);border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite;"></div>
        <div id="loadingText" style="font-size:.7rem;font-weight:600;color:var(--text-dim);">Loading...</div>
      </div>
      <style>@keyframes spin{to{transform:rotate(360deg);}}</style>
      <div style="position:absolute;top:10px;right:10px;display:flex;flex-direction:column;gap:.4rem;">
        <button id="zoomIn" class="btn-muted" style="width:38px;height:38px;font-size:1rem;">+</button>
        <button id="zoomOut" class="btn-muted" style="width:38px;height:38px;font-size:1rem;">−</button>
        <button id="zoomReset" class="btn-muted" style="width:38px;height:38px;font-size:.7rem;">Reset</button>
      </div>
    </div>

    <div class="panel" style="padding:1rem;">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:.6rem;">
        <div class="panel-header">Artifact Explorer</div>
        <input id="artifactSearch" class="input" placeholder="Search artifacts..." style="max-width:240px;" />
      </div>
      <div id="artifactTypeQuick" style="display:flex;flex-wrap:wrap;gap:.4rem;margin-bottom:.5rem;"></div>
      <div style="max-height:340px;overflow:auto;">
        <table class="artifact-table">
          <thead>
            <tr>
              <th data-sort="type">Type</th>
              <th data-sort="id">ID / Name</th>
              <th data-sort="detail">Detail</th>
              <th data-sort="tables">Tables</th>
            </tr>
          </thead>
          <tbody id="artifactTableBody"></tbody>
        </table>
      </div>
    </div>
  </main>
</div>

<div id="evidenceModalBackdrop">
  <div id="evidenceModal">
    <header>
      <span>Detection Evidence</span>
      <button id="evidenceCloseBtn" class="small alt" style="padding:4px 8px;">✕</button>
    </header>
    <div class="modal-body">
      <div class="filters">
        <label style="display:flex;flex-direction:column;font-size:.55rem;">
          Side
          <select id="evidenceSideFilter" class="input" style="width:120px;font-size:.58rem;">
            <option value="all">All</option>
            <option value="CCF">CCF</option>
            <option value="HTTP">HTTP</option>
          </select>
        </label>
        <label style="display:flex;flex-direction:column;font-size:.55rem;">
          Search
          <input id="evidenceSearch" class="input" placeholder="pattern or snippet..." style="width:180px;font-size:.58rem;">
        </label>
        <button id="evidenceExpandBtn" class="small alt">Expand All</button>
        <button id="evidenceCopyBtn" class="small alt">Copy</button>
        <div id="evidenceCount" style="font-size:.55rem;font-weight:600;color:var(--text-dim);margin-left:auto;"></div>
      </div>
      <div id="evidenceRows"></div>
    </div>
    <div class="footer-actions">
      <button id="evidenceCloseBtn2" class="small alt">Close</button>
    </div>
  </div>
</div>

<script>
/* ================= CONFIG & STATE ================= */
const CONFIG={D3_VERSION:'7.9.0',ENABLE_BRANCH_AUTODETECT:true,MAX_LOG_LINES:600};
const STATE={
  cache:new Map(),
  layoutMode:'force',
  includeNonCore:true,
  showEdgeLabels:false,
  degreeScaled:false,
  showIsolated:true,
  zoom:{x:0,y:0,k:1},
  highlighted:null,
  fetching:false,
  artifacts:null,
  fullGraph:null,
  graph:{nodes:[],links:[]},
  meta:null,
  createUiAnalysis:null,
  solutionAnalysis:null,
  simulation:null,
  dark:true
};
window.STATE=STATE;

/* ================= HELPERS ================= */
const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));
function log(msg,err=false){
  const el=$('#log'); if(!el)return;
  const ts=new Date().toISOString().split('T')[1].replace('Z','');
  const line=document.createElement('div');
  line.textContent=`[${ts}] ${msg}`;
  line.style.color=err?'#dc2626':'var(--text-dim)';
  el.appendChild(line);
  while(el.children.length>CONFIG.MAX_LOG_LINES) el.removeChild(el.firstChild);
  el.scrollTop=el.scrollHeight;
}
function setStatus(m,err=false){ const s=$('#status'); if(s){s.textContent=m; s.style.color=err?'var(--danger)':'var(--text-dim)';} log(m,err); }
function escapeHtml(str){ if(str==null)return''; return String(str).replace(/[&<>\"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }
function debounce(fn,ms){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms);} }
function toggleLoader(on,text='Loading...'){ $('#loadingOverlay').style.display=on?'flex':'none'; $('#loadingText').textContent=text; }

/* ================= D3 LOADING ================= */
function ensureD3(){return !!window.d3;}
(function loadD3(){
  if(ensureD3())return;
  const s=document.createElement('script');
  s.src=`https://cdnjs.cloudflare.com/ajax/libs/d3/${CONFIG.D3_VERSION}/d3.min.js`;
  s.onload=()=>log('D3 loaded');
  s.onerror=()=>log('D3 failed to load',true);
  document.head.appendChild(s);
})();

/* ================= GITHUB FETCHERS ================= */
function ghHeaders(){
  const t=$('#tokenInput')?.value.trim();
  const h={'Accept':'application/vnd.github+json'};
  if(t) h.Authorization=`token ${t}`;
  return h;
}
function updateRateLimit(res){
  if(!res?.headers)return;
  const rem=res.headers.get('x-ratelimit-remaining');
  const lim=res.headers.get('x-ratelimit-limit');
  const reset=res.headers.get('x-ratelimit-reset');
  if(rem && lim){
    $('#rateLimit').textContent=`Rate: ${rem}/${lim}${reset?` (reset ${new Date(+reset*1000).toLocaleTimeString()})`:''}`;
  }
}
async function fetchJson(url,purpose='',tries=3){
  if(STATE.cache.has(url)) return STATE.cache.get(url);
  for(let i=1;i<=tries;i++){
    try{
      const res=await fetch(url,{headers:ghHeaders()});
      updateRateLimit(res);
      if(!res.ok) throw new Error(`HTTP ${res.status} ${purpose} @ ${url}`);
      const j=await res.json(); STATE.cache.set(url,j); return j;
    }catch(e){
      log(`Retry ${i}/${tries} ${purpose}: ${e.message}`,true);
      if(i===tries) throw e;
      await new Promise(r=>setTimeout(r,350*i));
    }
  }
}

/* Primary listing with fallback */
async function listSolutionJsonPaths(owner,repo,branch,solution){
  try{
    const b=await fetch(`https://api.github.com/repos/${owner}/${repo}/branches/${encodeURIComponent(branch)}`,{headers:ghHeaders()});
    updateRateLimit(b); if(!b.ok) throw new Error(`Branch lookup failed ${b.status}`);
    const bj=await b.json(); const sha=bj?.commit?.commit?.tree?.sha;
    if(!sha) throw new Error('Missing tree SHA');
    const tUrl=`https://api.github.com/repos/${owner}/${repo}/git/trees/${sha}?recursive=1`;
    const t=await fetch(tUrl,{headers:ghHeaders()});
    updateRateLimit(t); if(!t.ok) throw new Error(`Tree fetch failed ${t.status}`);
    const tj=await t.json();
    const prefix=`Solutions/${solution}/`;
    const paths=(tj.tree||[])
      .filter(n=>n.type==='blob' && n.path.startsWith(prefix) && n.path.toLowerCase().endsWith('.json'))
      .map(n=>n.path);
    if(!paths.length) throw new Error('No JSON via tree, fallback');
    return paths;
  }catch(err){
    log(`Primary enumeration failed: ${err.message}; fallback.`,true);
    return await listSolutionJsonPathsFallback(owner,repo,branch,solution);
  }
}
async function listSolutionJsonPathsFallback(owner,repo,branch,solution){
  const base=`https://api.github.com/repos/${owner}/${repo}/contents/Solutions/${encodeURIComponent(solution)}`;
  const out=[];
  async function walk(dir){
    const url=`${base}${dir?'/'+dir:''}?ref=${encodeURIComponent(branch)}`;
    const res=await fetch(url,{headers:ghHeaders()}); updateRateLimit(res);
    if(!res.ok) throw new Error(`Fallback contents failed ${res.status} @ ${url}`);
    const items=await res.json();
    for(const it of items){
      if(it.type==='dir') await walk(dir?`${dir}/${it.name}`:it.name);
      else if(it.type==='file' && it.name.toLowerCase().endsWith('.json'))
        out.push(`Solutions/${solution}${dir?'/'+dir:''}/${it.name}`);
    }
  }
  await walk('');
  return out;
}
async function detectDefaultBranch(owner,repo){
  try{
    const r=await fetch(`https://api.github.com/repos/${owner}/${repo}`,{headers:ghHeaders()});
    if(!r.ok)return null;
    const j=await r.json(); return j.default_branch;
  }catch{return null;}
}
async function listSolutions(owner,repo,branch){
  const r=await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/Solutions?ref=${encodeURIComponent(branch)}`,{headers:ghHeaders()});
  updateRateLimit(r); if(!r.ok) throw new Error(`Solutions list failed: ${r.status}`);
  const j=await r.json();
  return (j||[]).filter(x=>x.type==='dir').map(x=>x.name).sort();
}

/* ================= QUERY & EXTRACTION HELPERS ================= */
function extractTablesFromQuery(q){
  if(!q) return [];
  // Broaden: custom tables (_CL, _CE, _CF), common built-ins, generic Events suffix
  const coreBuiltIns = [
    'CommonSecurityLog','Syslog','SecurityAlert','SecurityIncident','Heartbeat','AzureActivity',
    'SigninLogs','AuditLogs','OfficeActivity','ApplicationGatewayFirewallLog',
    'VMConnection','DnsEvents','DeviceEvents','DeviceNetworkEvents'
  ];
  const pattern = new RegExp(
    '\\b(' +
      coreBuiltIns.join('|') +
    '|[A-Za-z0-9_]+_(CL|CE|CF)' +
    '|[A-Za-z0-9]+Events?' +
    ')\\b','g');
  const set=new Set();
  for(const m of q.matchAll(pattern)){ set.add(m[1]); }
  return [...set];
}
function summarizeQueryMetrics(q){
  if(!q) return {lines:0,length:0};
  const lines=q.split(/\r?\n/).filter(l=>l.trim()).length;
  return {lines,length:q.length};
}
function extractEndpointsGeneric(json){
  const set=new Set();
  function walk(o){
    if(!o||typeof o!=='object')return;
    if(Array.isArray(o)){o.forEach(walk);return;}
    for(const k in o){
      const v=o[k];
      if(typeof v==='string'){
        if(/(endpoint|baseUrl|baseURL|url|host|apiRoot|apiEndpoint|tokenUrl|authUrl)$/i.test(k)) capture(v);
        const u=v.match(/https?:\/\/[^\s"'<>{}]+/g); if(u) u.forEach(capture);
      }else if(typeof v==='object') walk(v);
    }
  }
  function capture(u){
    if(!/^https?:\/\//i.test(u))return;
    try{ const host=new URL(u).host.toLowerCase(); if(host) set.add(host);}catch{}
  }
  walk(json);
  return [...set].slice(0,20);
}
function normalizeMetaList(input){
  if(input==null) return [];
  if(Array.isArray(input))
    return [...new Set(input.flatMap(v=>normalizeMetaList(v)).filter(s=>typeof s==='string'&&s.trim()).map(s=>s.trim()))];
  if(typeof input==='string')
    return input.split(/[,;]+/).map(s=>s.trim()).filter(Boolean);
  if(typeof input==='object'){
    const out=[];
    for(const [k,v] of Object.entries(input)){
      if(typeof v==='boolean' && v) out.push(k);
      else if(typeof v==='string' && v.trim()) out.push(v.trim());
      else if(Array.isArray(v)) out.push(...normalizeMetaList(v));
      else if(v && typeof v==='object'){
        const cand=['name','displayName','title','value','category','domain','id','label']
          .find(c=>typeof v[c]==='string'&&v[c].trim());
        if(cand) out.push(v[cand].trim()); else out.push(...normalizeMetaList(v));
      }
    }
    return [...new Set(out)];
  }
  return [];
}
function detectKindCategory(json){
  const k=(json?.kind||json?.properties?.kind||'').toLowerCase();
  const txt=JSON.stringify(json).toLowerCase();
  const hasUi=json?.properties?.connectorUiConfig||json?.properties?.connectorUIConfig;
  const hasDcr=json?.properties?.dcrConfig;
  if(/restapipoller|apipolling/.test(k)) return 'CCF – API Poller';
  if(/codeless/.test(k)||hasUi) return 'CCF – UI';
  if(hasDcr) return 'CCF – DCR';
  if(/logs ingestion api/.test(txt)) return 'Logs Ingestion API';
  if(/azurefunction/.test(k)) return 'Azure Function';
  if(/http data collector|datacollector/.test(txt)||/datacollector/.test(k)) return 'HTTP Data Collector';
  if(/pollinterval|pollingfrequency/.test(txt)) return 'API Polling';
  return '';
}

/* ================= DCR FLOW NORMALIZER ================= */
function normalizeDcrFlows(rawFlows){
  if(!Array.isArray(rawFlows)) return [];
  return rawFlows.map((f,i)=>{
    const streams=[...(f.streams||[])].map(s=>String(s));
    const tf=f.transformKql||f.transformKQL||'';
    const transformLines=tf?tf.split(/\r?\n/).filter(l=>l.trim()).length:0;
    const transformChars=tf.length;
    const outputTables=new Set();
    if(tf){
      const into=tf.match(/into\s+table\s+([a-zA-Z0-9_]+)/gi);
      if(into) into.forEach(m=>{
        const t=m.split(/\s+/).pop();
        if(t) outputTables.add(t);
      });
    }
    if(Array.isArray(f.destinations)){
      f.destinations.forEach(d=>{
        if(typeof d==='string') outputTables.add(d);
        else if(d && typeof d==='object'){
          const n=d.table||d.name||d.id;
          if(n) outputTables.add(n);
        }
      });
    }
    return {
      id:`flow${i+1}`,
      index:i,
      streams,
      outputTables:[...outputTables],
      transformLines,
      transformChars,
      hasTransform:!!tf
    };
  });
}

/* ================= CLASSIFICATION ================= */

const DEBUG_CLASSIFY = false; // set true for verbose classification logging

function isAnalyticRule(json){
  if(!json || typeof json!=='object') return false;
  const p=json.properties||{};
  const kind=(json.kind||p.kind||'').toLowerCase();
  const query=(p.query||'').trim();
  const hasQuery=query.length>10; // simple threshold
  const hasSeverity=!!p.severity;
  const hasTactics=Array.isArray(p.tactics) && p.tactics.length>0;
  const analyticKinds=new Set(['scheduled','nrt','fusion','anomaly','behavior','mlbehavioranalytics','microsoftsecurityincidentcreation']);
  const kindHit=[...analyticKinds].some(k=>kind.includes(k));
  return hasQuery && (hasSeverity || hasTactics || kindHit);
}


function extractServiceEndpoints(json){
  const out=new Set();
  const text=JSON.stringify(json||{}).toLowerCase();
  // Match API path fragments (not just hosts)
  const pathMatches = text.match(/\/api\/(events?|event|agents?|alerts?|logs|messages|telemetry|ingest)\b[^\s"']*/g) || [];
  pathMatches.forEach(p=>{
    // Normalize trimming trailing punctuation
    out.add(p.replace(/[",\s]+$/,''));
  });
  // Poller hint -> synthetic endpoint
  if(/restapipoller|api\s*polling/.test(text) && ![...out].some(e=>/\/api\/events?/.test(e))){
    out.add('poller://event-api'); // synthetic marker
  }
  return [...out].slice(0,25);
}



// ================= UPDATED classifyArtifact =================

function classifyArtifact(json, path) {
  const fileName = path.split('/').pop();
  const lowerFile = fileName.toLowerCase();
  const lowerPath = path.toLowerCase();
  let rawStr=''; try { rawStr = JSON.stringify(json||{}); } catch {}
  const ltext = rawStr.toLowerCase();

  const baseDisplay =
    json?.name ||
    json?.displayName ||
    json?.title ||
    json?.properties?.displayName ||
    fileName.replace(/\.json$/,'');

  // Exclusions (core/support)
  const EXCLUDE_FILE = new Set([
    'dcr.json','pollerconfig.json','createuidefinition.json','solutionmetadata.json',
    'maintemplate.json','azuredeploy.json','tables.json','tableschema.json'
  ]);

  /* ---------- CORE / INFRA (unchanged from earlier logic except guarded by EXCLUDE_FILE) ---------- */
  if(/main(template)?\.json$/i.test(fileName)){
    const resources=[];
    (function collect(arr){ if(Array.isArray(arr)) arr.forEach(r=>{ resources.push(r); if(Array.isArray(r?.resources)) collect(r.resources);}); })(json.resources);
    let dc=0,ar=0,wb=0,pb=0,other=0;
    resources.forEach(r=>{
      const t=(r.type||'').toLowerCase();
      if(t.endsWith('/dataconnectors')) dc++;
      else if(t.includes('alertrules')) ar++;
      else if(t.endsWith('/workbooks')) wb++;
      else if(t.endsWith('/workflows')) pb++;
      else other++;
    });
    return {
      type:'filecore',
      id:'mainTemplate.json',
      path,
      raw:json,
      coreKind:'mainTemplate',
      resourceCounts:{ total:resources.length,dataConnectors:dc,analyticRules:ar,workbooks:wb,playbooks:pb,others:other },
      endpoints:extractEndpointsGeneric(json),
      serviceEndpoints:extractServiceEndpoints(json)
    };
  }
  if(lowerFile==='solutionmetadata.json'){
    return {
      type:'filecore', id:'solutionMetadata.json', path, raw:json, coreKind:'solutionMetadata',
      contentHubId:json.contentHubId||'', version:json.version||'', listingId:json.listingId||'',
      offerId:json.offerId||json.offerID||json.marketplaceOfferId||'',
      categories:normalizeMetaList(json.categories||json.category),
      domains:normalizeMetaList(json.domains||json.domain),
      endpoints:[]
    };
  }
  if(lowerFile==='createuidefinition.json'){
    const steps=(rawStr.match(/"steps"\s*:/gi)||[]).length;
    const params=(rawStr.match(/"parameters"\s*:/gi)||[]).length;
    return {
      type:'filecore', id:'createUiDefinition.json', path, raw:json, coreKind:'createUiDefinition',
      stepsCount:steps, parametersCount:params,
      endpoints:extractEndpointsGeneric(json),
      serviceEndpoints:extractServiceEndpoints(json)
    };
  }
  if(lowerFile==='pollerconfig.json'){
    const schedule=json.schedule||json.pollInterval||json.frequency||json.interval||'';
    return {
      type:'filecore', id:'pollerConfig.json', path, raw:json, coreKind:'pollerConfig',
      schedule: typeof schedule==='object'?JSON.stringify(schedule):String(schedule||''),
      endpoints:extractEndpointsGeneric(json),
      serviceEndpoints:extractServiceEndpoints(json)
    };
  }
  if(lowerFile==='dcr.json'){
    const flows=json?.properties?.dataFlows||json?.dataFlows||[];
    const flowsData=normalizeDcrFlows(flows);
    const streams=new Set(); flows.forEach(f=>(f.streams||[]).forEach(s=>streams.add(s)));
    return {
      type:'filecore', id:'dcr.json', path, raw:json, coreKind:'dcr',
      dataFlows:flows.length, streamCount:streams.size, flowsData,
      endpoints:extractEndpointsGeneric(json),
      serviceEndpoints:extractServiceEndpoints(json)
    };
  }
  if(lowerFile==='host.json'||lowerFile==='functionapp.json'){
    return { type:'functioninfra', id:fileName, path, raw:json, bindingsCount:rawStr.length, endpoints:extractEndpointsGeneric(json) };
  }
  if(lowerFile==='azuredeploy.json'){
    return { type:'deployment', id:'azuredeploy.json', path, raw:json,
      resourceCount:Array.isArray(json?.resources)?json.resources.length:0,
      endpoints:extractEndpointsGeneric(json)
    };
  }

  /* ---------- OTHER TYPES (same as before) ---------- */
  if(/\/watchlists\//i.test(lowerPath)||/"microsoft\.securityinsights\/watchlists"/.test(ltext)){
    return { type:'watchlist', id:baseDisplay, path, raw:json, description:json?.properties?.description||'' };
  }
  if(/\/parsers\//i.test(lowerPath)||/\/functions\//i.test(lowerPath)||/"functionalias"|\"parsertype\"/i.test(ltext)){
    const kql=json?.properties?.query||json?.query||json?.kql||'';
    return {
      type:'kqlfunction', id:baseDisplay, path, raw:json,
      tables:extractTablesFromQuery(kql), queryMetrics:summarizeQueryMetrics(kql)
    };
  }
  if(/\/notebooks?\//i.test(lowerPath)&&/"cells":\s*\[/.test(ltext)){
    return { type:'notebook', id:baseDisplay, path, raw:json, cellCount:(json.cells||[]).length };
  }
  if(lowerPath.includes('/workbooks/') || /"microsoft\.insights\/workbooks"/.test(ltext) || (/"workbook"/.test(ltext)&&json?.properties?.serializedData)){
    const query=json?.properties?.query||json?.query||'';
    return {
      type:'workbook', id:baseDisplay, path, raw:json,
      description:json?.properties?.description||'',
      tables:extractTablesFromQuery(query), queryMetrics:summarizeQueryMetrics(query)
    };
  }
  const analyticPathHint=
    /\/analytic[s]?[ _-]?rules?\//i.test(lowerPath) ||
    /\/alert[ _-]?rules?\//i.test(lowerPath) ||
    /\/detection[s]?\//i.test(lowerPath) ||
    /\/alertrules\//i.test(lowerPath);
  if(analyticPathHint || isAnalyticRule(json)){
    const p=json.properties||{};
    const query=p.query||json.query||'';
    const severity=p.severity||json.severity||'';
    const tactics=(p.tactics||json.tactics||[]).join(', ');
    return {
      type:'analyticrule', id:p.displayName||json.displayName||baseDisplay, path, raw:json,
      tables:extractTablesFromQuery(query), severity, tactics, queryMetrics:summarizeQueryMetrics(query)
    };
  }
  if(/\/hunting queries\//i.test(lowerPath)||/\/huntingqueries\//i.test(lowerPath)||(json?.tags && json.tags['hidden-sentinelContentType']==='HuntingQuery')){
    const query=json?.properties?.query||json?.query||'';
    return {
      type:'huntingquery', id:baseDisplay, path, raw:json,
      tables:extractTablesFromQuery(query), queryMetrics:summarizeQueryMetrics(query)
    };
  }
  if(/\/playbooks\//i.test(lowerPath)||(json?.definition||json?.properties?.definition)){
    const wf=json?.definition||json?.properties?.definition;
    return {
      type:'playbook', id:baseDisplay, path, raw:json,
      triggers:wf?.triggers?Object.keys(wf.triggers).length:0,
      actions:wf?.actions?Object.keys(wf.actions).length:0
    };
  }

  /* ---------- DCR-LIKE DEPENDENCY (non-core) ---------- */
  if(lowerFile!=='dcr.json' && (/microsoft\.insights\/datacollectionrules/.test(ltext)||json?.properties?.dataFlows||json?.dataFlows)){
    const flows=json?.properties?.dataFlows||json?.dataFlows||[];
    const flowsData=normalizeDcrFlows(flows);
    const tables=new Set(), streams=new Set();
    flows.forEach(f=>{
      (f.streams||[]).forEach(s=>streams.add(String(s).toLowerCase()));
      const tf=f.transformKql||f.transformKQL||'';
      const into=tf.match(/into\s+table\s+([a-z0-9_]+)/ig);
      if(into) into.forEach(m=>{
        const t=m.split(/\s+/).pop(); if(t) tables.add(t.toLowerCase());
      });
    });
    flowsData.forEach(fd=>fd.outputTables.forEach(t=>tables.add(t.toLowerCase())));
    return {
      type:'dependency', id:baseDisplay, path, raw:json,
      dataFlows:flows.length, tables:[...tables].sort(), streams:[...streams].sort(),
      flowsData, endpoints:extractEndpointsGeneric(json), serviceEndpoints:extractServiceEndpoints(json)
    };
  }

  /* ---------- CONNECTOR DETECTION (tight) ---------- */
  if(EXCLUDE_FILE.has(lowerFile)) {
    // These are never the connector definition (already handled above)
    return { type:'json', id:baseDisplay, path, raw:json };
  }

  const props = json?.properties||{};
  const metaKind=(json?.metadata?.kind||props?.metadata?.kind||'').toLowerCase();
  const rawKind=(json?.kind||props?.kind||'').toLowerCase();

  const uiCfg=props.connectorUiConfig||props.connectorUIConfig;
  const dcrCfg=props.dcrConfig;
  const dataTypes = Array.isArray(props.dataTypes)?props.dataTypes:[];
  const graphQueries = Array.isArray(uiCfg?.graphQueries)?uiCfg.graphQueries:[];
  const streamDecl = Array.isArray(dcrCfg?.streamDeclarations)?dcrCfg.streamDeclarations:[];
  const connectorId = props.connectorId || json.id || props.id;

  const inConnectorFolder = /Solutions\/[^/]+\/(Data[ _-]?Connectors?|DataConnectors|Connectors?)\//i.test(path);

  const strongSignals = [];
  const mediumSignals = [];
  const identitySignals = [];

  if(dcrCfg) strongSignals.push('dcrConfig');
  if(uiCfg) strongSignals.push('uiConfig');
  if(metaKind==='dataconnector') strongSignals.push('metadata.kind=dataConnector');
  if(rawKind==='dataconnector') strongSignals.push('kind=dataConnector');
  if(/restapipoller|apipolling/.test(rawKind)) mediumSignals.push('restApiPoller');
  if(/codeless/.test(rawKind)) mediumSignals.push('codelessKind');

  if(dataTypes.length) mediumSignals.push('dataTypes');
  if(graphQueries.length) mediumSignals.push('graphQueries');
  if(streamDecl.length) mediumSignals.push('streamDeclarations');

  if(connectorId) identitySignals.push('connectorId');

  // Quick negative: if only medium signals = streamDeclarations (from a DCR-like) AND no strong signals & not in connector folder -> not a connector
  if(!strongSignals.length && !identitySignals.length && !inConnectorFolder) {
    return { type:'json', id:baseDisplay, path, raw:json };
  }

  // Required anchor: at least one of (connectorId, metadata.kind=dataConnector, uiConfig, dcrConfig)
  const hasAnchor = connectorId || uiCfg || dcrCfg || (metaKind==='dataconnector');
  if(!hasAnchor) {
    return { type:'json', id:baseDisplay, path, raw:json };
  }

  // Score
  let score = strongSignals.length*5 + mediumSignals.length*2 + (identitySignals.length?2:0);
  if(inConnectorFolder) score += 1;
  if(score < 5 && !inConnectorFolder) {
    // Too weak outside canonical folder
    return { type:'json', id:baseDisplay, path, raw:json };
  }

  const ingestionType = dcrCfg ? 'CCF-DCR' :
                        uiCfg ? 'CCF-UI' :
                        (streamDecl.length && dataTypes.length ? 'CCF-DCR' : 'Unknown');

  const tables = dataTypes.map(dt=>dt?.name||dt).filter(Boolean);
  const streams = streamDecl.map(s=>s?.streamName).filter(Boolean);

  const title = uiCfg?.title || uiCfg?.displayName || props.displayName || json.title || json.name || baseDisplay;
  const desc = uiCfg?.description || props.description || json.descriptionMarkdown || '';
  const publisher = uiCfg?.publisher || props.publisher || props.author || json.publisher || '';
  const domain = uiCfg?.domain || props.domain || '';
  const logo = uiCfg?.logo || props.logo || json.logo || '';
  const metricNames = graphQueries.map(g=>g?.metricName).filter(Boolean);

  log(`Connector candidate(score=${score}): ${connectorId||title} strong=[${strongSignals}] medium=[${mediumSignals}] folder=${inConnectorFolder}`);

  return {
    type:'connector',
    id:title,
    rawId:connectorId || title,
    path,
    raw:json,
    mechanism:ingestionType,
    ingestionType,
    kindCategory:
      ingestionType==='CCF-DCR'?'CCF – DCR':
      ingestionType==='CCF-UI'?'CCF – UI':'',
    tables:[...new Set(tables)],
    streams:[...new Set(streams)],
    description:desc,
    publisher,
    domain,
    metricNames:[...new Set(metricNames)],
    branding:{logo},
    endpoints:extractEndpointsGeneric(json),
    serviceEndpoints:extractServiceEndpoints(json),
    metadataKind: metaKind || undefined,
    rawKind: rawKind || undefined,
    score,
    strongSignals,
    mediumSignals,
    dir: path.slice(0, path.lastIndexOf('/'))
  };
}

// ================= UPDATED harvestEmbeddedArtifacts =================

function harvestEmbeddedArtifacts(artifacts){
  const mt = artifacts.coreFiles.find(c=>c.coreKind==='mainTemplate');
  if(!mt || !mt.raw) return;

  const resources = Array.isArray(mt.raw.resources) ? mt.raw.resources : [];
  const exists = (arr, id) => arr.some(x => x.id === id);

  resources.forEach(r=>{
    const t=(r.type||'').toLowerCase();
    const props=r.properties||{};

    // Embedded Data Connectors
    if(t.endsWith('/dataconnectors')){
      const connectorId = props.connectorId || props.displayName || r.name?.split('/').pop() || 'DataConnector';
      if(!exists(artifacts.connectors, connectorId)){
        const uiCfg=props.connectorUiConfig||props.connectorUIConfig;
        const dcrCfg=props.dcrConfig;
        const hasDcr=!!dcrCfg;
        const ingestionType = hasDcr ? 'CCF-DCR' : (uiCfg?'CCF-UI':'Unknown');
        artifacts.connectors.push({
          type:'connector',
          id:uiCfg?.title||uiCfg?.displayName||props.displayName||connectorId,
          rawId:connectorId,
          path:'(embedded mainTemplate)',
          raw:r,
            mechanism:ingestionType,
            ingestionType,
            kindCategory: hasDcr?'CCF – DCR': uiCfg?'CCF – UI':'',
            tables: Array.isArray(props.dataTypes)?props.dataTypes.map(dt=>dt?.name||dt).filter(Boolean):[],
            streams: dcrCfg?.streamDeclarations?dcrCfg.streamDeclarations.map(s=>s.streamName).filter(Boolean):[],
            description: uiCfg?.description||props.description||'',
            publisher: uiCfg?.publisher||props.publisher||'',
            domain: uiCfg?.domain||props.domain||'',
            metricNames: Array.isArray(uiCfg?.graphQueries)?[...new Set(uiCfg.graphQueries.map(g=>g?.metricName).filter(Boolean))]:[],
            branding:{logo: uiCfg?.logo||props.logo||''},
            endpoints: extractEndpointsGeneric(r),
            serviceEndpoints: extractServiceEndpoints(r),
            embedded:true,
            score: 100,
            strongSignals: ['embeddedResource'],
            mediumSignals: [],
            dir: '(embedded)'
        });
        log(`Embedded connector harvested: ${connectorId}`);
      }
    }

    // (Other embedded artifact types omitted here for brevity—retain existing code if you had it)
  });
}

// ---- NEW helper: choose one connector definition per directory ----
function refineConnectorCandidates(list){
  if(!Array.isArray(list) || list.length===0) return list;
  const groups = list.reduce((m,c)=>{
    const key = c.dir || '';
    if(!m[key]) m[key]=[];
    m[key].push(c);
    return m;
  },{});
  const out=[];
  Object.entries(groups).forEach(([dir, arr])=>{
    if(arr.length===1 || dir==='(embedded)'){
      out.push(...arr);
      return;
    }
    // Pick highest score; tie-breaker: has dcrConfig, then uiConfig, then more tables
    arr.sort((a,b)=>{
      if(b.score !== a.score) return b.score - a.score;
      const aStrong = (a.strongSignals||[]).includes('dcrConfig') ? 2 :
                      (a.strongSignals||[]).includes('uiConfig') ? 1 : 0;
      const bStrong = (b.strongSignals||[]).includes('dcrConfig') ? 2 :
                      (b.strongSignals||[]).includes('uiConfig') ? 1 : 0;
      if(bStrong !== aStrong) return bStrong - aStrong;
      return (b.tables?.length||0) - (a.tables?.length||0);
    });
    const primary = arr[0];
    out.push(primary);
    arr.slice(1).forEach(support=>{
      log(`Connector support file (same dir -> not counted): ${support.rawId||support.id} dir=${dir}`);
    });
  });
  return out;
}


// (Ensure buildArtifacts still calls harvestEmbeddedArtifacts(acc) after classification & dedupe.)

function refineConnectorCandidates(list){
  if(!Array.isArray(list) || list.length===0) return list;
  const groups = list.reduce((m,c)=>{
    const key = c.dir || '';
    if(!m[key]) m[key]=[];
    m[key].push(c);
    return m;
  },{});
  const out=[];
  Object.entries(groups).forEach(([dir, arr])=>{
    if(arr.length===1 || dir==='(embedded)'){
      out.push(...arr);
      return;
    }
    // Pick highest score; tie-breaker: has dcrConfig, then uiConfig, then more tables
    arr.sort((a,b)=>{
      if(b.score !== a.score) return b.score - a.score;
      const aStrong = (a.strongSignals||[]).includes('dcrConfig') ? 2 :
                      (a.strongSignals||[]).includes('uiConfig') ? 1 : 0;
      const bStrong = (b.strongSignals||[]).includes('dcrConfig') ? 2 :
                      (b.strongSignals||[]).includes('uiConfig') ? 1 : 0;
      if(bStrong !== aStrong) return bStrong - aStrong;
      return (b.tables?.length||0) - (a.tables?.length||0);
    });
    const primary = arr[0];
    out.push(primary);
    arr.slice(1).forEach(support=>{
      log(`Connector support file (same dir -> not counted): ${support.rawId||support.id} dir=${dir}`);
    });
  });
  return out;
}

// ---- REVISED buildArtifacts inserting refine step & removing earlier extra dedupe ----
function buildArtifacts(files){
  const acc = {
    connectors:[], dcrs:[], workbooks:[], analytics:[], hunting:[],
    playbooks:[], watchlists:[], functions:[], notebooks:[], infra:[],
    deploy:[], others:[], coreFiles:[], serviceEndpoints:[], files:[]
  };

  acc.files = (Array.isArray(files)?files:[]).map(f=>{
    let text=''; try{ text=JSON.stringify(f.json).toLowerCase(); }catch{}
    return { path:f.path, name:f.path.split('/').pop(), raw:f.json, text };
  });

  files.forEach(f=>{
    const c = classifyArtifact(f.json, f.path);
    if(!c){ log('Classifier returned null for '+f.path,true); return; }
    switch(c.type){
      case 'connector': acc.connectors.push(c); break;
      case 'dependency': acc.dcrs.push(c); break;
      case 'workbook': acc.workbooks.push(c); break;
      case 'analyticrule': acc.analytics.push(c); break;
      case 'huntingquery': acc.hunting.push(c); break;
      case 'playbook': acc.playbooks.push(c); break;
      case 'watchlist': acc.watchlists.push(c); break;
      case 'kqlfunction': acc.functions.push(c); break;
      case 'notebook': acc.notebooks.push(c); break;
      case 'functioninfra': acc.infra.push(c); break;
      case 'deployment': acc.deploy.push(c); break;
      case 'filecore': acc.coreFiles.push(c); break;
      default: acc.others.push(c);
    }
  });

  // Embedded harvest
  harvestEmbeddedArtifacts(acc);

  // First dedupe (identity)
  acc.connectors = dedupeConnectors(acc.connectors);

  // Directory refinement (keep single definitive per dir)
  acc.connectors = refineConnectorCandidates(acc.connectors);

  // Re-dedupe just in case refinement produced duplicates merging dirs
  acc.connectors = dedupeConnectors(acc.connectors);

  // Link connectors -> DCR dependencies
  const dcrNamesLower = new Map(acc.dcrs.map(d=>[d.id.toLowerCase(), d.id]));
  acc.connectors.forEach(conn=>{
    const txt = JSON.stringify(conn.raw||{}).toLowerCase();
    conn.linkedDcrIds = [];
    dcrNamesLower.forEach((orig, low)=>{ if(txt.includes(low)) conn.linkedDcrIds.push(orig); });
  });

  // Aggregate service endpoints
  const seMap = new Map();
  function addServiceEndpoints(list, sourceType, sourceId){
    (list||[]).forEach(se=>{
      const key=se.toLowerCase();
      if(!seMap.has(key)) seMap.set(key,{id:se,sources:[]});
      seMap.get(key).sources.push({type:sourceType,id:sourceId});
    });
  }
  acc.connectors.forEach(c=>addServiceEndpoints(c.serviceEndpoints,'connector',c.id));
  acc.dcrs.forEach(d=>addServiceEndpoints(d.serviceEndpoints,'dcr',d.id));
  acc.coreFiles.filter(cf=>cf.coreKind==='dcr'&&cf.serviceEndpoints?.length)
               .forEach(cf=>addServiceEndpoints(cf.serviceEndpoints,'core',cf.id));
  acc.serviceEndpoints=[...seMap.values()];

  log(`Artifact build complete: connectors=${acc.connectors.length}, dcrs=${acc.dcrs.length}, embedded=${acc.connectors.filter(c=>c.embedded).length}`);

  return acc;
}

/* KEEP ONLY THIS dedupeConnectors (remove older duplicate) */
function dedupeConnectors(list){
  if(!Array.isArray(list)||list.length<=1) return list;
  function canonicalKey(c){
    const rawId=(c.raw?.properties?.connectorId)||(c.raw?.id)||c.rawId||c.id||'';
    return rawId.toLowerCase()
      .replace(/\(.*?\)/g,'')
      .replace(/connector|integration|data$/g,'')
      .replace(/[\s._-]+/g,'')
      .replace(/v\d+$/,'');
  }
  function score(c){
    const rank = c.ingestionType==='CCF-DCR'?5:
                 c.ingestionType==='CCF-UI'?4:
                 c.ingestionType==='HTTP Data Collector'?3:
                 c.ingestionType==='Azure Function'?2:1;
    const richness=(c.tables?.length||0)+(c.streams?.length||0);
    return rank*10 + richness - (c.path||'').length/800 + (c.score||0)/10;
  }
  const groups=[...list.reduce((m,c)=>{
    const k=canonicalKey(c);
    if(!m.has(k)) m.set(k,[]);
    m.get(k).push(c);
    return m;
  },new Map()).entries()];
  const out=[];
  groups.forEach(([key,arr])=>{
    if(arr.length===1){ out.push(arr[0]); return; }
    arr.sort((a,b)=>score(b)-score(a));
    out.push(arr[0]);
    arr.slice(1).forEach(c=>log(`Dedup (drop variant) ${c.id}`));
  });
  return out;
}


/* Updated dedupeConnectors to leverage rawId aggressively */
function dedupeConnectors(list){
  if(!Array.isArray(list)||list.length<=1) return list;
  function canonicalKey(c){
    const rawId=(c.raw?.id)|| (c.raw?.properties?.connectorId) || c.rawId || c.id || '';
    return String(rawId).toLowerCase()
      .replace(/\(.*?\)/g,'')
      .replace(/connector|integration|data$/g,'')
      .replace(/[\s._-]+/g,'')
      .replace(/v\d+$/,'');
  }
  function score(c){
    const rank=c.ingestionType==='CCF-DCR'?5:
               c.ingestionType==='CCF-UI'?4:
               c.ingestionType==='HTTP Data Collector'?3:
               c.ingestionType==='Azure Function'?2:1;
    const richness=(c.tables?.length||0)+(c.streams?.length||0);
    const penalty=/sample|test|old|deprecated|legacy/i.test(c.path||'')?-3:0;
    return rank*12 + richness + penalty - (c.path||'').length/600;
  }
  function jaccard(a,b){
    if(!a.size && !b.size) return 1;
    let inter=0; a.forEach(v=>{if(b.has(v)) inter++;});
    const uni=a.size+b.size-inter;
    return uni? inter/uni:0;
  }
  const groups=[...list.reduce((m,c)=>{
    const k=canonicalKey(c);
    if(!m.has(k)) m.set(k,[]);
    m.get(k).push(c);
    return m;
  },new Map()).entries()];
  const out=[];
  groups.forEach(([key,arr])=>{
    if(arr.length===1){ out.push(arr[0]); return; }
    arr.sort((a,b)=>score(b)-score(a));
    const primary=arr[0];
    const primarySet=new Set([...(primary.tables||[]),...(primary.streams||[])].map(s=>s.toLowerCase()));
    out.push(primary);
    for(let i=1;i<arr.length;i++){
      const cand=arr[i];
      const candSet=new Set([...(cand.tables||[]),...(cand.streams||[])].map(s=>s.toLowerCase()));
      const sim=jaccard(primarySet,candSet);
      if(sim>=0.7){
        log(`Dedup connector dropped "${cand.id}" (sim ${sim.toFixed(2)})`);
      }else{
        out.push(cand);
      }
    }
  });
  return out;
}



/* Connector dedupe */
function dedupeConnectors(list){
  if(!Array.isArray(list)||list.length<=1) return list;
  function canonicalKey(c){
    const rawId=(c.raw?.properties?.connectorId)||c.id||'';
    return rawId.toLowerCase()
      .replace(/\(.*?\)/g,'')
      .replace(/connector|integration|data$/g,'')
      .replace(/[\s._-]+/g,'')
      .replace(/v\d+$/,'');
  }
  function score(c){
    const rank=c.ingestionType==='CCF-DCR'?4:c.ingestionType==='CCF-UI'?3:c.ingestionType==='HTTP Data Collector'?2:1;
    const richness=(c.tables?.length||0)+(c.streams?.length||0);
    const penalty=/sample|test|old|deprecated|legacy/i.test(c.path||'')?-3:0;
    return rank*10+richness+penalty-(c.path||'').length/500;
  }
  function jaccard(a,b){
    if(!a.size && !b.size) return 1;
    let inter=0; a.forEach(v=>{if(b.has(v)) inter++;});
    const uni=a.size+b.size-inter;
    return uni? inter/uni:0;
  }
  const groups=[...list.reduce((m,c)=>{
    const k=canonicalKey(c);
    if(!m.has(k)) m.set(k,[]);
    m.get(k).push(c);
    return m;
  },new Map()).entries()];
  const out=[];
  groups.forEach(([key,arr])=>{
    if(arr.length===1){ out.push(arr[0]); return; }
    arr.sort((a,b)=>score(b)-score(a));
    const primary=arr[0];
    const primarySet=new Set([...(primary.tables||[]),...(primary.streams||[])].map(s=>s.toLowerCase()));
    out.push(primary);
    for(let i=1;i<arr.length;i++){
      const cand=arr[i];
      const candSet=new Set([...(cand.tables||[]),...(cand.streams||[])].map(s=>s.toLowerCase()));
      const sim=jaccard(primarySet,candSet);
      if(sim>=0.7){
        log(`Dedup connector: dropping "${cand.id}" similarity ${sim.toFixed(2)}`);
      }else{
        out.push(cand);
      }
    }
  });
  return out;
}

/* Build artifacts bucket */
function buildArtifacts(files){
  const acc = {
    connectors:[],
    dcrs:[],
    workbooks:[],
    analytics:[],
    hunting:[],
    playbooks:[],
    watchlists:[],
    functions:[],
    notebooks:[],
    infra:[],
    deploy:[],
    others:[],
    coreFiles:[],
    serviceEndpoints:[], // aggregated later
    files:[]             // raw file list (path + raw + pre-lowered text)
  };

  // Build raw file list early (supports analyzer line-level)
  acc.files = (Array.isArray(files)?files:[]).map(f=>{
    let text='';
    try{ text = JSON.stringify(f.json).toLowerCase(); }catch{}
    return {
      path:f.path,
      name:f.path.split('/').pop(),
      raw:f.json,
      text
    };
  });

  // Classify each file
  files.forEach(f=>{
    const c = classifyArtifact(f.json, f.path);
    if(!c){
      log('Classifier undefined for '+f.path, true);
      return;
    }
    switch(c.type){
      case 'connector':     acc.connectors.push(c); break;
      case 'dependency':    acc.dcrs.push(c); break;
      case 'workbook':      acc.workbooks.push(c); break;
      case 'analyticrule':  acc.analytics.push(c); break;
      case 'huntingquery':  acc.hunting.push(c); break;
      case 'playbook':      acc.playbooks.push(c); break;
      case 'watchlist':     acc.watchlists.push(c); break;
      case 'kqlfunction':   acc.functions.push(c); break;
      case 'notebook':      acc.notebooks.push(c); break;
      case 'functioninfra': acc.infra.push(c); break;
      case 'deployment':    acc.deploy.push(c); break;
      case 'filecore':      acc.coreFiles.push(c); break;
      default:              acc.others.push(c);
    }
  });

  // Deduplicate connectors (existing helper)
  acc.connectors = dedupeConnectors(acc.connectors);

  // Link connectors to DCR dependencies (simple name text match)
  const dcrNamesLower = new Map(acc.dcrs.map(d=>[d.id.toLowerCase(), d.id]));
  acc.connectors.forEach(conn=>{
    const txt = JSON.stringify(conn.raw||{}).toLowerCase();
    conn.linkedDcrIds = [];
    dcrNamesLower.forEach((orig, low)=>{
      if(txt.includes(low)) conn.linkedDcrIds.push(orig);
    });
  });

  // Aggregate service endpoints from connectors, dependency DCRs, and core DCR files
  const seMap = new Map();
  function addServiceEndpoints(list, sourceType, sourceId){
    (list||[]).forEach(se=>{
      const key = se.toLowerCase();
      if(!seMap.has(key)){
        seMap.set(key, { id: se, sources: [] });
      }
      seMap.get(key).sources.push({ type: sourceType, id: sourceId });
    });
  }
  acc.connectors.forEach(c=> addServiceEndpoints(c.serviceEndpoints, 'connector', c.id));
  acc.dcrs.forEach(d=> addServiceEndpoints(d.serviceEndpoints, 'dcr', d.id));
  acc.coreFiles.filter(cf=>cf.coreKind==='dcr' && cf.serviceEndpoints?.length)
               .forEach(cf=> addServiceEndpoints(cf.serviceEndpoints, 'core', cf.id));

  acc.serviceEndpoints = [...seMap.values()];

  // Enrich connectors with a synthetic flag if they have poller endpoints but no explicit event API
  acc.connectors.forEach(c=>{
    if(c.serviceEndpoints && c.serviceEndpoints.some(se=>/poller:\/\/event-api/i.test(se))){
      c.hasEventApiPoller = true;
    }
  });

  return acc;
}

/* Harvest embedded content (mainTemplate) */
function harvestEmbeddedArtifacts(artifacts){
  const mt=artifacts.coreFiles.find(c=>c.coreKind==='mainTemplate');
  if(!mt||!mt.raw) return;
  const resources=Array.isArray(mt.raw.resources)?mt.raw.resources:[];
  const exists=(arr,id)=>arr.some(x=>x.id===id);
  resources.forEach(r=>{
    const t=(r.type||'').toLowerCase();
    if(/workbooks$/.test(t)){
      const id=r.name?.split('/').pop()||r.properties?.displayName||'Workbook';
      if(!exists(artifacts.workbooks,id)){
        const query=r.properties?.query||'';
        artifacts.workbooks.push({type:'workbook',id,path:'(embedded mainTemplate)',raw:r,
          description:r.properties?.description||'',tables:extractTablesFromQuery(query),
          queryMetrics:summarizeQueryMetrics(query)});
      }
    }
    if(/alertrules$/.test(t)){
      const props=r.properties||{}; const query=props.query||'';
      const id=props.displayName||r.name?.split('/').pop()||'AnalyticRule';
      if(!exists(artifacts.analytics,id)){
        artifacts.analytics.push({type:'analyticrule',id,path:'(embedded mainTemplate)',raw:r,
          severity:props.severity||'',tactics:(props.tactics||[]).join(', '),
          tables:extractTablesFromQuery(query),queryMetrics:summarizeQueryMetrics(query)});
      }
    }
    if(/watchlists$/.test(t)){
      const id=r.name?.split('/').pop()||r.properties?.displayName||'Watchlist';
      if(!exists(artifacts.watchlists,id)){
        artifacts.watchlists.push({type:'watchlist',id,path:'(embedded mainTemplate)',raw:r,
          description:r.properties?.description||''});
      }
    }
    if(t.endsWith('/savedsearches') && r.properties?.category==='Function'){
      const id=r.properties?.displayName||r.name?.split('/').pop()||'Function';
      if(!exists(artifacts.functions,id)){
        const kql=r.properties?.query||'';
        artifacts.functions.push({type:'kqlfunction',id,path:'(embedded mainTemplate)',raw:r,
          tables:extractTablesFromQuery(kql),queryMetrics:summarizeQueryMetrics(kql)});
      }
    }
  });
}

/* ================= META & ANALYSIS ================= */
function deriveSolutionId(solutionFolder,sm={},mt={}){
  const guid=/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;
  const keys=['contentHubId','solutionId','solutionID','listingId','id','offerId','offerID','solutionUniqueId','packageId','contentId','packageID','contentID'];
  const direct=keys.map(k=>sm[k]).find(v=>typeof v==='string'&&v.trim());
  if(direct) return direct.trim();
  const ser=JSON.stringify(sm); const g=ser.match(guid); if(g) return g[0];
  const params=mt.parameters||{};
  for(const [k,v] of Object.entries(params)){
    if(/solution/i.test(k)&&/(id|guid)/i.test(k)){
      const dv=v?.defaultValue||v;
      if(typeof dv==='string'){
        const m=dv.match(guid); return m?m[0]:dv.trim();
      }
    }
  }
  if(sm.offerId) return sm.offerId;
  return solutionFolder;
}
async function extractSolutionMeta(owner,repo,branch,solution,paths){
  const base=`https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(branch)}/`;
  const mtPath=paths.find(p=>/main(template)?\.json$/i.test(p));
  const smPath=paths.find(p=>/solutionmetadata\.json$/i.test(p));
  let mt={}, sm={};
  if(mtPath) mt=await fetchJson(base+mtPath,'mainTemplate')||{};
  if(smPath) sm=await fetchJson(base+smPath,'solutionMetadata')||{};

  function paramPick(...cands){
    for(const cand of cands){
      const seg=cand.split('.'); let cur=mt;
      for(const s of seg){ cur=cur?cur[s]:undefined; }
      if(typeof cur==='string'&&cur.trim()) return cur.trim();
      if(cur && typeof cur==='object' && typeof cur.defaultValue==='string') return cur.defaultValue.trim();
    }
    return '';
  }
  const solutionName=sm.name||sm.displayName||sm.solutionName||
    paramPick('parameters.SolutionName','parameters.solutionName','parameters.solution','parameters.name')||
    solution;
  const publisher=sm.publisherName||sm.publisher||sm.publisherId||
    paramPick('parameters.Publisher','parameters.publisher','parameters.publisherName')||'Unknown';
  const offerId=sm.offerId||sm.offerID||sm.marketplaceOfferId||'';
  const categories=normalizeMetaList(sm.categories||sm.category);
  const domains=normalizeMetaList(sm.domains||sm.domain);
  const solutionId=deriveSolutionId(solution,sm,mt);
  const resources=[];(function collect(a){ if(Array.isArray(a)) a.forEach(r=>{resources.push(r); if(Array.isArray(r.resources)) collect(r.resources);});})(mt.resources);
  let dc=0,ar=0,wb=0,pb=0,others=0;
  resources.forEach(r=>{
    const t=(r.type||'').toLowerCase();
    if(t.endsWith('/dataconnectors')) dc++;
    else if(t.includes('alertrules')) ar++;
    else if(t.endsWith('/workbooks')) wb++;
    else if(t.endsWith('/workflows')) pb++;
    else others++;
  });
  return {
    solutionName,solutionId,publisher,offerId,categories,domains,
    mainTemplateResourceCounts:{total:resources.length,dataConnectors:dc,analyticRules:ar,workbooks:wb,playbooks:pb,others},
    rawSolutionMeta:sm
  };
}


/* ================================================
   Architecture Analyzer Constants (tunable)
   ================================================ */
const ARCH_CONST = {
  odsHostRe: /(\/\/|\.)(ods|opinsights)\.azure\.(com|cn|us|de|gov)(\/|:|$)/i,
  apiLogsRe: /\/api\/logs(\?|$)/i,
  sharedKeyHdrRe: /authorization:\s*sharedkey/i,
  logTypeHdrRe: /(^|\W)log-type(\W|$)/i,
  xmsDateHdrRe: /x-ms-date/i,
  timeGenFieldRe: /time-generated-field/i,
  // Mode thresholds
  modes: {
    strict:  { majorityPct: 0.65, strongDelta: 3 },
    balanced:{ majorityPct: 0.60, strongDelta: 2 },
    lenient: { majorityPct: 0.55, strongDelta: 2 }
  }
};
/*
function analyzeSolutionArchitecture(art, options={}){
  if(!art) return {
    type:'Unknown',
    reasoning:'No artifacts loaded.',
    connectors:[],
    evidence:[],
    signalsCatalog:{connectors:[],core:[]},
    counts:{ccf:0,http:0,mixed:0,neutral:0,total:0},
    core:{},
    confidence:0,
    reasoningLines:['No artifacts loaded.'],
    evidenceLines:[]
  };

  const modeCfg = ARCH_CONST.modes[options.mode] || ARCH_CONST.modes.balanced;
  const tiePref = options.tieBreakPreference || 'ccf';

  // ---------- helpers ----------
  const toTxt = v => {
    try { return (typeof v === 'string' ? v : JSON.stringify(v||{})).toLowerCase(); }
    catch { return ''; }
  };
  const fileList = Array.isArray(art.files) ? art.files : [];
  const coreList = Array.isArray(art.coreFiles) ? art.coreFiles : [];

  const fileNameSet = new Set(
    fileList.map(f => (f.path || f.name || '').toLowerCase()).filter(Boolean)
  );
  const hasAnyFileNamed = (...needles) => needles.some(n => {
    n = n.toLowerCase();
    for(const f of fileNameSet){
      if(f.endsWith('/'+n) || f === n || f.includes('/'+n)) return true;
    }
    return false;
  });

  // Packaging / CCF artifacts
  const hasConnectorDefinitionFile = hasAnyFileNamed('connectorDefinition.json');
  const hasPollerConfigFile        = hasAnyFileNamed('pollerConfig.json');
  const hasAnyDcrJson              = hasAnyFileNamed('dcr.json','dcr.config.json','dataCollectionRule.json');
  const hasAnyTableSchema          = hasAnyFileNamed('tableSchema.json','tables.json');
  const packagingArtifacts = {
    connectorDefinition: hasConnectorDefinitionFile,
    pollerConfig: hasPollerConfigFile,
    dcrJson: hasAnyDcrJson,
    tableSchema: hasAnyTableSchema
  };

  // ---------- per-connector analysis ----------
  const connectorSignals = [];
  const connectors = (art.connectors||[]).map(c=>{
    const raw = c.raw || {};
    const txt = toTxt(raw);
    const mech = (c.mechanism||'').toLowerCase();
    const id = c.id || c.name || c.path || 'connector';

    const strongCcf = new Set();
    const weakCcf   = new Set();
    const strongHttp= new Set();
    const weakHttp  = new Set();

    const props = raw?.properties || {};
    const hasDcrConfig = !!props?.dcrConfig;
    const hasUiConfig  = !!(props?.connectorUiConfig || props?.connectorUIConfig);
    const dataTypes    = Array.isArray(props?.dataTypes) ? props.dataTypes : [];
    const graphQueries = Array.isArray(props?.graphQueries) ? props.graphQueries : [];
    const hasStreams   = Array.isArray(c.streams) && c.streams.length>0;

    const localSignals = { id, ccf:{ strong:[], weak:[] }, http:{ strong:[], weak:[] } };

    // CCF signals
    const fullCodeless = hasDcrConfig && hasUiConfig && dataTypes.length && graphQueries.length;
    if(fullCodeless){ strongCcf.add('codeless-full'); localSignals.ccf.strong.push('codeless-full (dcrConfig+uiConfig+dataTypes+graphQueries)'); }
    if(hasDcrConfig && !fullCodeless){ strongCcf.add('dcrConfig'); localSignals.ccf.strong.push('properties.dcrConfig'); }
    // streams downgraded to weak unless full codeless present
    if(hasStreams && !fullCodeless){ weakCcf.add('streams'); localSignals.ccf.weak.push('connector.streams (weak)'); }
    if(/restapipoller|api\s*polling|pollerconfig|poller-config/.test(txt)){
      strongCcf.add('apiPoller'); localSignals.ccf.strong.push('text: restApiPoller|api polling|pollerConfig');
    }
    if(hasUiConfig && !fullCodeless){
      weakCcf.add('uiConfig'); localSignals.ccf.weak.push('properties.connectorUiConfig');
    }
    if(/codeless/.test(txt) && !fullCodeless){
      weakCcf.add('codeless-keyword'); localSignals.ccf.weak.push('text: codeless');
    }
    if(graphQueries.length && !hasDcrConfig){
      weakCcf.add('graphQueries-only'); localSignals.ccf.weak.push('properties.graphQueries without dcrConfig');
    }

    // HTTP signals
    const hasWorkspaceId = /workspaceid|customerid|la_workspace_id/.test(txt);
    const hasSharedKey   = /sharedkey|workspacekey|primarykey/.test(txt);
    const hasSignature   = /x-ms-signature/.test(txt) || ARCH_CONST.sharedKeyHdrRe.test(txt);
    const hasApiLogs     = ARCH_CONST.apiLogsRe.test(txt);
    const hasOpInsights  = ARCH_CONST.odsHostRe.test(txt);
    const hasLogAnalyticsUri = /loganalyticsuri/.test(txt) && (hasOpInsights || /azure\.(com|cn|us|de|gov)/.test(txt));
    const mentionsCollector = /datacollector|http data collector|data collector api/i.test(txt) || mech.includes('http data collector');

    if(hasWorkspaceId && hasSharedKey &&
       (hasApiLogs || hasOpInsights || hasLogAnalyticsUri || hasSignature)){
      strongHttp.add('workspaceId+sharedKey+endpoint/signature');
      localSignals.http.strong.push('workspaceId+sharedKey + (api/logs|ODS|logAnalyticsUri|signature)');
    } else {
      if(hasWorkspaceId){ weakHttp.add('workspaceId'); localSignals.http.weak.push('workspaceId|customerId|la_workspace_id'); }
      if(hasSharedKey){   weakHttp.add('sharedKey');   localSignals.http.weak.push('sharedKey|workspaceKey|primaryKey'); }
    }
    if(hasSignature){       strongHttp.add('x-ms-signature'); localSignals.http.strong.push('header: x-ms-signature or Authorization: SharedKey'); }
    if(hasApiLogs){         strongHttp.add('/api/logs');       localSignals.http.strong.push('path: /api/logs'); }
    if(hasLogAnalyticsUri){ strongHttp.add('logAnalyticsUri'); localSignals.http.strong.push('param: logAnalyticsUri + Azure host'); }
    else if(hasOpInsights){ weakHttp.add('opinsights-host');   localSignals.http.weak.push('host: *.ods|opinsights.azure.*'); }
    if(mentionsCollector){  weakHttp.add('data-collector-mention'); localSignals.http.weak.push('keyword: data collector api'); }
    if(ARCH_CONST.logTypeHdrRe.test(txt)){   weakHttp.add('Log-Type-header');      localSignals.http.weak.push('header: Log-Type'); }
    if(ARCH_CONST.xmsDateHdrRe.test(txt)){   weakHttp.add('x-ms-date-header');     localSignals.http.weak.push('header: x-ms-date'); }
    if(ARCH_CONST.timeGenFieldRe.test(txt)){ weakHttp.add('time-generated-field'); localSignals.http.weak.push('field: time-generated-field'); }

    // Scoring
    const scoreCcf  = strongCcf.size*3 + weakCcf.size;
    const scoreHttp = strongHttp.size*3 + weakHttp.size;
    let arch='Neutral';
    if(scoreCcf===0 && scoreHttp===0) arch='Neutral';
    else if(scoreCcf >= scoreHttp + modeCfg.strongDelta) arch='CCF';
    else if(scoreHttp >= scoreCcf + modeCfg.strongDelta) arch='HTTP';
    else {
      if(strongCcf.size > strongHttp.size) arch='CCF';
      else if(strongHttp.size > strongCcf.size) arch='HTTP';
      else arch='Mixed';
    }

    connectorSignals.push(localSignals);

    return {
      id,
      arch,
      strongCcf:[...strongCcf],
      weakCcf:[...weakCcf],
      strongHttp:[...strongHttp],
      weakHttp:[...weakHttp],
      score:{ ccf:scoreCcf, http:scoreHttp }
    };
  });

  // ---------- counts ----------
  const counts = connectors.reduce((acc,c)=>{
    acc[c.arch]=(acc[c.arch]||0)+1;
    acc.total++;
    return acc;
  },{total:0});

  // ---------- core reinforcement ----------
  let coreHasDcr=false, coreHasDce=false, coreHasWorkspaceCreds=false, coreHasApiLogs=false;
  const coreSignals = [];

  function collectResources(raw){
    const out=[];
    (function walk(arr){
      if(Array.isArray(arr)) arr.forEach(r=>{
        out.push(r);
        if(Array.isArray(r.resources)) walk(r.resources);
      });
    })(raw?.resources);
    return out;
  }

  coreList.forEach(cf=>{
    const raw=cf.raw||{};
    const txt=toTxt(raw);
    collectResources(raw).forEach(r=>{
      const t=(r?.type||'').toLowerCase();
      if(t==='microsoft.insights/datacollectionrules'){ coreHasDcr=true; coreSignals.push('resource: dataCollectionRules'); }
      if(t==='microsoft.insights/datacollectionendpoints'){ coreHasDce=true; coreSignals.push('resource: dataCollectionEndpoints'); }
      if(t==='microsoft.insights/datacollectionrules/associations'){ coreHasDcr=true; coreSignals.push('resource: DCR associations'); }
    });
    if(ARCH_CONST.apiLogsRe.test(txt)){ coreHasApiLogs=true; coreSignals.push('http: /api/logs in core'); }
    if(/workspaceid/.test(txt) && /sharedkey|workspacekey|primarykey/.test(txt)){
      coreHasWorkspaceCreds=true; coreSignals.push('http: workspaceId+sharedKey in core');
    }
    if(ARCH_CONST.odsHostRe.test(txt) && /workspaceid/.test(txt)){
      coreSignals.push('http: ODS host + workspaceId');
    }
  });

  const corePackaging = [];
  if(packagingArtifacts.connectorDefinition){ corePackaging.push('packaging: connectorDefinition.json'); }
  if(packagingArtifacts.pollerConfig){        corePackaging.push('packaging: pollerConfig.json'); }
  if(packagingArtifacts.dcrJson){             corePackaging.push('packaging: DCR json'); }
  if(packagingArtifacts.tableSchema){         corePackaging.push('packaging: table schema'); }
  coreSignals.push(...corePackaging);

  const core = {
    ccfArtifacts: corePackaging.length>0,
    dcrResource: coreHasDcr,
    dceResource: coreHasDce,
    httpApiLogs: coreHasApiLogs,
    workspaceKeyPair: coreHasWorkspaceCreds
  };

  // ---------- final decision ----------
  const strongCcfConnectors = connectors.filter(c=>c.arch==='CCF');
  const strongHttpConnectors= connectors.filter(c=>c.arch==='HTTP');
  const mixedConnectors     = connectors.filter(c=>c.arch==='Mixed');
  const neutralConnectors   = connectors.filter(c=>c.arch==='Neutral');
  const pct = v => connectors.length ? v/connectors.length : 0;
  const totalStrong = (arr,side) => arr.reduce((s,c)=> s + (side==='ccf'?c.strongCcf.length:c.strongHttp.length),0);

  let type='Unknown';
  if(connectors.length===0){
    if(core.ccfArtifacts || core.dcrResource || core.dceResource) type='CCF';
    else if(core.httpApiLogs || core.workspaceKeyPair) type='HTTP Data Collector API';
  } else {
    if(strongCcfConnectors.length && !strongHttpConnectors.length && !mixedConnectors.length) type='CCF';
    else if(strongHttpConnectors.length && !strongCcfConnectors.length && !mixedConnectors.length) type='HTTP Data Collector API';
    else if(pct(strongCcfConnectors.length) >= modeCfg.majorityPct) type='CCF';
    else if(pct(strongHttpConnectors.length) >= modeCfg.majorityPct) type='HTTP Data Collector API';
    else {
      const ccfStrongTotal  = totalStrong(connectors,'ccf');
      const httpStrongTotal = totalStrong(connectors,'http');
      if(ccfStrongTotal > httpStrongTotal) type='CCF';
      else if(httpStrongTotal > ccfStrongTotal) type='HTTP Data Collector API';
      else {
        // tie-break
        if(core.ccfArtifacts || core.dcrResource || core.dceResource){
          type='CCF';
        } else if(core.httpApiLogs || core.workspaceKeyPair){
          type='HTTP Data Collector API';
        } else {
            if(tiePref==='ccf') type='CCF';
            else if(tiePref==='http') type='HTTP Data Collector API';
            else type='Unknown';
        }
      }
    }
  }
  if(!type) type='Unknown';

  // ---------- confidence ----------
  const majorityShare = Math.max(pct(strongCcfConnectors.length), pct(strongHttpConnectors.length));
  let confidence = 0.15 + 0.55*majorityShare;
  if(type==='CCF'){
    if(core.ccfArtifacts) confidence += 0.12;
    if(core.dcrResource || core.dceResource) confidence += 0.08;
    if(core.httpApiLogs) confidence -= 0.05;
  } else if(type==='HTTP Data Collector API'){
    if(core.httpApiLogs) confidence += 0.12;
    if(core.workspaceKeyPair) confidence += 0.06;
    if(core.dcrResource || core.dceResource) confidence -= 0.05;
  } else if(type==='Unknown'){
    confidence = 0.05;
  }
  // penalty for heavy mixed connectors
  const mixedRatio = pct(mixedConnectors.length);
  confidence -= mixedRatio*0.10;
  confidence = Math.max(0,Math.min(1,confidence));

    // NEW: Force confidence to 100% if any DCR evidence exists
  const hasConnectorDcr = connectors.some(c =>
    c.strongCcf.includes('dcrConfig') ||
    c.strongCcf.includes('codeless-full') // full codeless implies dcrConfig
  );
  const hasPackagingDcr = packagingArtifacts.dcrJson; // earlier variable in function
  if (core.dcrResource || hasPackagingDcr || hasConnectorDcr) {
    confidence = 1.0;
  }


  // ---------- reasoning + evidence ----------
  const reasoningLines = [];
  reasoningLines.push(`Final Classification: ${type}`);
  reasoningLines.push(`Connectors distribution: CCF=${strongCcfConnectors.length}, HTTP=${strongHttpConnectors.length}, Mixed=${mixedConnectors.length}, Neutral=${neutralConnectors.length}, Total=${connectors.length}`);
  if(core.ccfArtifacts || core.dcrResource || core.dceResource)
    reasoningLines.push(`Core CCF signals: ${[
      core.ccfArtifacts?'packaging artifacts':'',
      core.dcrResource?'DCR resources':'',
      core.dceResource?'DCE resources':''
    ].filter(Boolean).join(', ')}`);
  if(core.httpApiLogs || core.workspaceKeyPair)
    reasoningLines.push(`Core HTTP signals: ${[
      core.httpApiLogs?'/api/logs':'',
      core.workspaceKeyPair?'workspaceId+sharedKey':''
    ].filter(Boolean).join(', ')}`);
  const sideSignals = type==='CCF'
    ? strongCcfConnectors.flatMap(c=>c.strongCcf)
    : strongHttpConnectors.flatMap(c=>c.strongHttp);
  reasoningLines.push(sideSignals.length
    ? `Dominant strong signals: ${[...new Set(sideSignals)].join(', ')}`
    : 'Dominant strong signals: (none aggregated; majority/core tie-break applied)');
  reasoningLines.push(`Mode: ${options.mode||'balanced'}; tieBreakPreference: ${tiePref}`);
  reasoningLines.push(`Confidence: ${confidence.toFixed(2)}`);
  reasoningLines.push(`Streams treated as weak unless part of full codeless bundle.`);
  reasoningLines.push(`Strong HTTP requires endpoint/signature context (reduces param-only false positives).`);

  const evidenceLines = [];
  connectors.forEach(c=>{
    if(c.strongCcf.length) evidenceLines.push(`${c.id}: CCF strong [${c.strongCcf.join(', ')}]`);
    if(c.strongHttp.length) evidenceLines.push(`${c.id}: HTTP strong [${c.strongHttp.join(', ')}]`);
    if(!c.strongCcf.length && !c.strongHttp.length && c.arch!=='Neutral')
      evidenceLines.push(`${c.id}: ${c.arch} (weak/mixed signals)`);
  });
  if(core.ccfArtifacts)   evidenceLines.push('Core: packaging artifacts (connectorDefinition/pollerConfig/DCR/table schema)');
  if(core.dcrResource)    evidenceLines.push('Core: dataCollectionRules resource(s)');
  if(core.dceResource)    evidenceLines.push('Core: dataCollectionEndpoints resource(s)');
  if(core.httpApiLogs)    evidenceLines.push('Core: /api/logs flow');
  if(core.workspaceKeyPair) evidenceLines.push('Core: workspaceId+sharedKey parameters');

  const reasoning = 'Architecture Reasoning:\n' + reasoningLines.map(l=>'• '+l).join('\n');
  const evidence  = 'Ingestion Evidence:\n' + evidenceLines.map(l=>'• '+l).join('\n');

  return {
    type,
    connectors,
    counts:{
      ccf: strongCcfConnectors.length,
      http: strongHttpConnectors.length,
      mixed: mixedConnectors.length,
      neutral: neutralConnectors.length,
      total: connectors.length
    },
    core,
    confidence,
    reasoning,
    evidence,
    reasoningLines,
    evidenceLines,
    signalsCatalog:{
      connectors: connectorSignals,
      core: coreSignals
    }
  };
}
*/

function analyzeSolutionArchitecture(art, options={}){
  if(!art) return {
    type:'CCF', // forced fallback to one of the two
    connectors:[],
    counts:{ccf:0,http:0,total:0},
    core:{},
    reasoning:'CCF: no artifacts loaded; defaulting per enforced binary classification.',
    evidence:[],
    reasoningLines:['Defaulted to CCF (no artifacts).'],
    evidenceLines:[],
    signalsCatalog:{connectors:[],core:[]}
  };

  const toTxt = v => {
    try { return (typeof v === 'string' ? v : JSON.stringify(v||{})).toLowerCase(); }
    catch { return ''; }
  };

  // File name inspection for packaging artifacts
  const fileList = Array.isArray(art.files) ? art.files : [];
  const fileNameSet = new Set(fileList.map(f => (f.path||f.name||'').toLowerCase()).filter(Boolean));
  const hasAnyFileNamed = (...needles) => needles.some(n => {
    n = n.toLowerCase();
    for(const f of fileNameSet){
      if(f.endsWith('/'+n) || f === n || f.includes('/'+n)) return true;
    }
    return false;
  });

  // Regex constants
  const odsHostRe = /(\/\/|\.)(ods|opinsights)\.azure\.(com|cn|us|de|gov)(\/|:|$)/i;
  const apiLogsRe = /\/api\/logs(\?|$)/i;
  const sharedKeyHdrRe = /authorization:\s*sharedkey/i;
  const logTypeHdrRe = /(^|\W)log-type(\W|$)/i;
  const xmsDateHdrRe = /x-ms-date/i;
  const timeGenFieldRe = /time-generated-field/i;

  // Packaging artifacts (strong CCF indicators)
  const hasConnectorDefinitionFile = hasAnyFileNamed('connectorDefinition.json');
  const hasPollerConfigFile        = hasAnyFileNamed('pollerConfig.json');
  const hasAnyDcrJson              = hasAnyFileNamed('dcr.json','dcr.config.json','dataCollectionRule.json');
  const hasAnyTableSchema          = hasAnyFileNamed('tableSchema.json','tables.json');

  // Per-connector analysis
  const connectorSignals = [];
  const connectors = (art.connectors||[]).map(c=>{
    const raw = c.raw || {};
    const txt = toTxt(raw);
    const mech = (c.mechanism||'').toLowerCase();
    const id = c.id || c.name || c.path || 'connector';

    const strongCcf = new Set();
    const weakCcf   = new Set();
    const strongHttp= new Set();
    const weakHttp  = new Set();

    const props = raw.properties || {};
    const hasDcrConfig = !!props.dcrConfig;
    const hasUiConfig  = !!(props.connectorUiConfig || props.connectorUIConfig);
    const dataTypes    = Array.isArray(props.dataTypes)?props.dataTypes:[];
    const graphQueries = Array.isArray(props.graphQueries)?props.graphQueries:[];
    const hasStreams   = Array.isArray(c.streams)&&c.streams.length>0;

    const localSignals = { id, ccf:{strong:[],weak:[]}, http:{strong:[],weak:[]} };

    const fullCodeless = hasDcrConfig && hasUiConfig && dataTypes.length && graphQueries.length;
    if(fullCodeless){ strongCcf.add('codeless-full'); localSignals.ccf.strong.push('codeless-full'); }
    if(hasDcrConfig && !fullCodeless){ strongCcf.add('dcrConfig'); localSignals.ccf.strong.push('dcrConfig'); }
    if(/restapipoller|api\s*polling|pollerconfig|poller-config/.test(txt)){ strongCcf.add('apiPoller'); localSignals.ccf.strong.push('apiPoller'); }
    if(hasUiConfig && !fullCodeless){ weakCcf.add('uiConfig'); localSignals.ccf.weak.push('uiConfig'); }
    if(graphQueries.length && !hasDcrConfig){ weakCcf.add('graphQueries'); localSignals.ccf.weak.push('graphQueries-only'); }
    if(hasStreams && !fullCodeless){ weakCcf.add('streams'); localSignals.ccf.weak.push('streams'); }
    if(/codeless/.test(txt) && !fullCodeless){ weakCcf.add('codeless-keyword'); localSignals.ccf.weak.push('codeless-keyword'); }

    // HTTP signals
    const hasWorkspaceId = /workspaceid|customerid|la_workspace_id/.test(txt);
    const hasSharedKey   = /sharedkey|workspacekey|primarykey/.test(txt);
    const hasSignature   = /x-ms-signature/.test(txt) || sharedKeyHdrRe.test(txt);
    const hasApiLogs     = apiLogsRe.test(txt);
    const hasOpInsights  = odsHostRe.test(txt);
    const hasLogAnalyticsUri = /loganalyticsuri/.test(txt) && (hasOpInsights || /azure\.(com|cn|us|de|gov)/.test(txt));
    const mentionsCollector = /datacollector|http data collector|data collector api/i.test(txt) || mech.includes('http data collector');

    if(hasWorkspaceId && hasSharedKey && (hasApiLogs || hasOpInsights || hasLogAnalyticsUri || hasSignature)){
      strongHttp.add('workspaceId+sharedKey+endpoint/signature');
      localSignals.http.strong.push('workspaceId+sharedKey+endpoint/signature');
    } else {
      if(hasWorkspaceId){ weakHttp.add('workspaceId'); localSignals.http.weak.push('workspaceId'); }
      if(hasSharedKey){   weakHttp.add('sharedKey');   localSignals.http.weak.push('sharedKey'); }
    }
    if(hasSignature){       strongHttp.add('x-ms-signature');     localSignals.http.strong.push('x-ms-signature'); }
    if(hasApiLogs){         strongHttp.add('/api/logs');          localSignals.http.strong.push('/api/logs'); }
    if(hasLogAnalyticsUri){ strongHttp.add('logAnalyticsUri');    localSignals.http.strong.push('logAnalyticsUri'); }
    else if(hasOpInsights){ weakHttp.add('opinsights-host');      localSignals.http.weak.push('opinsights-host'); }
    if(mentionsCollector){  weakHttp.add('data-collector');       localSignals.http.weak.push('data-collector-mention'); }
    if(logTypeHdrRe.test(txt)){   weakHttp.add('Log-Type');       localSignals.http.weak.push('Log-Type-header'); }
    if(xmsDateHdrRe.test(txt)){   weakHttp.add('x-ms-date');      localSignals.http.weak.push('x-ms-date-header'); }
    if(timeGenFieldRe.test(txt)){ weakHttp.add('time-generated'); localSignals.http.weak.push('time-generated-field'); }

    const scoreCcf  = strongCcf.size*3 + weakCcf.size;
    const scoreHttp = strongHttp.size*3 + weakHttp.size;

    // Connector-level arch forced binary
    let arch;
    if(scoreCcf === 0 && scoreHttp === 0) {
      arch = 'CCF'; // arbitrary default to align with global rule
    } else if(scoreCcf >= scoreHttp) arch='CCF';
    else arch='HTTP';

    connectorSignals.push(localSignals);

    return {
      id,
      arch,
      strongCcf:[...strongCcf],
      weakCcf:[...weakCcf],
      strongHttp:[...strongHttp],
      weakHttp:[...weakHttp],
      score:{ ccf:scoreCcf, http:scoreHttp }
    };
  });

  // Core template reinforcement (DCR / DCE / HTTP)
  const coreFiles = Array.isArray(art.coreFiles)?art.coreFiles:[];
  let coreHasDcr=false, coreHasDce=false, coreHasApiLogs=false, coreHasWorkspaceCreds=false;

  function collectResources(raw){
    const out=[];
    (function walk(arr){
      if(Array.isArray(arr)) arr.forEach(r=>{
        out.push(r);
        if(Array.isArray(r.resources)) walk(r.resources);
      });
    })(raw?.resources);
    return out;
  }

  coreFiles.forEach(cf=>{
    const raw=cf.raw||{};
    const txt=toTxt(raw);
    collectResources(raw).forEach(r=>{
      const t=(r?.type||'').toLowerCase();
      if(t==='microsoft.insights/datacollectionrules') coreHasDcr=true;
      if(t==='microsoft.insights/datacollectionendpoints') coreHasDce=true;
      if(t==='microsoft.insights/datacollectionrules/associations') coreHasDcr=true;
    });
    if(apiLogsRe.test(txt)) coreHasApiLogs=true;
    if(/workspaceid/.test(txt) && /sharedkey|workspacekey|primarykey/.test(txt)) coreHasWorkspaceCreds=true;
  });

  // Aggregate scores
  const totalCcfScore  = connectors.reduce((s,c)=>s+c.score.ccf,0);
  const totalHttpScore = connectors.reduce((s,c)=>s+c.score.http,0);

  const anyConnectorDcr = connectors.some(c=>c.strongCcf.includes('dcrConfig')||c.strongCcf.includes('codeless-full'));
  const packagingDcr = hasAnyDcrJson;

  // Final forced binary classification
  let type;
  if(coreHasDcr || anyConnectorDcr || packagingDcr) {
    type='CCF';
  } else if(!coreHasDcr && !anyConnectorDcr && !packagingDcr &&
            (coreHasApiLogs || (coreHasWorkspaceCreds && (totalHttpScore>0)) ||
             connectors.some(c=>c.strongHttp.length>0))) {
    type='HTTP Data Collector API';
  } else {
    // Score comparison fallback
    if(totalCcfScore >= totalHttpScore) type='CCF';
    else type='HTTP Data Collector API';
  }

  // Counts (binary)
  const counts = {
    ccf: connectors.filter(c=>c.arch==='CCF').length,
    http: connectors.filter(c=>c.arch==='HTTP').length,
    total: connectors.length
  };

  const core = {
    dcrResource: coreHasDcr,
    dceResource: coreHasDce,
    httpApiLogs: coreHasApiLogs,
    workspaceKeyPair: coreHasWorkspaceCreds,
    packaging: {
      connectorDefinition: hasConnectorDefinitionFile,
      pollerConfig: hasPollerConfigFile,
      dcrJson: hasAnyDcrJson,
      tableSchema: hasAnyTableSchema
    }
  };

  // Reasoning assembly
  const reasoningLines = [];
  reasoningLines.push(`Final Classification: ${type}`);
  reasoningLines.push(`Connector scores (aggregate): CCF=${totalCcfScore} HTTP=${totalHttpScore}`);
  reasoningLines.push(`Connector distribution: CCF=${counts.ccf} HTTP=${counts.http} Total=${counts.total}`);
  if(core.packaging.connectorDefinition || core.packaging.pollerConfig || core.packaging.dcrJson || core.packaging.tableSchema){
    reasoningLines.push('Packaging artifacts: '+
      Object.entries(core.packaging).filter(([k,v])=>v).map(([k])=>k).join(', '));
  }
  if(core.dcrResource) reasoningLines.push('Core template includes dataCollectionRules');
  if(core.dceResource) reasoningLines.push('Core template includes dataCollectionEndpoints');
  if(core.httpApiLogs) reasoningLines.push('Core template includes /api/logs flow');
  if(core.workspaceKeyPair) reasoningLines.push('Core template includes workspaceId+sharedKey parameters');
  if(anyConnectorDcr) reasoningLines.push('Connector-level dcrConfig detected');
  if(packagingDcr) reasoningLines.push('DCR JSON file present');
  reasoningLines.push('Binary fallback: ties or absence of decisive HTTP endpoint default to CCF.');
  const reasoning = 'Architecture Reasoning:\n' + reasoningLines.map(l=>'• '+l).join('\n');

  // Evidence list (strong signals only)
  const evidenceLines = [];
  connectors.forEach(c=>{
    if(c.strongCcf.length) evidenceLines.push(`${c.id}: CCF strong [${c.strongCcf.join(', ')}]`);
    if(c.strongHttp.length) evidenceLines.push(`${c.id}: HTTP strong [${c.strongHttp.join(', ')}]`);
  });
  if(core.packaging.connectorDefinition || core.packaging.pollerConfig) evidenceLines.push('Core: connectorDefinition/pollerConfig present');
  if(core.packaging.dcrJson) evidenceLines.push('Core: DCR JSON packaging present');
  if(core.dcrResource) evidenceLines.push('Core: dataCollectionRules resource');
  if(core.dceResource) evidenceLines.push('Core: dataCollectionEndpoints resource');
  if(core.httpApiLogs) evidenceLines.push('Core: /api/logs flow');
  if(core.workspaceKeyPair) evidenceLines.push('Core: workspaceId+sharedKey parameters');
  const evidence = 'Ingestion Evidence:\n' + evidenceLines.map(l=>'• '+l).join('\n');

  return {
    type,
    connectors,
    counts,
    core,
    reasoning,
    evidence,
    reasoningLines,
    evidenceLines,
    signalsCatalog:{
      connectors: connectorSignals,
      core: reasoningLines.filter(l=>/Core|Packaging|Connector-level|DCR JSON/.test(l))
    }
  };
}



function analyzeCreateUiDefinition(json){
  if(!json||typeof json!=='object') return null;
  const ser=JSON.stringify(json);
  const steps=(ser.match(/"steps"/gi)||[]).length;
  const connectors=(ser.match(/dataconnector/gi)||[]).length;
  const workbooks=(ser.match(/workbook/gi)||[]).length;
  const analytics=(ser.match(/analytic/i)||[]).length;
  const hunting=(ser.match(/hunting/i)||[]).length;
  const playbooks=(ser.match(/playbook|logic app/i)||[]).length;
  const basic=json?.parameters?.basics||json?.parameters?.config?.basics||{};
  const name=basic?.label||basic?.displayName||json?.name||json?.label||'';
  const desc=basic?.description||json?.description||'';
  return {
    solutionName:name,
    description:desc,
    implied:{dataConnectors:connectors,workbooks,analyticRules:analytics,huntingQueries:hunting,playbooks},
    steps,
    raw:json
  };
}

/* ================= GRAPH MODELS ================= */
const TYPE_META={
  solution:{label:'Solution',color:'#d8581d'},
  connector:{label:'Connector',color:'#26a69a'},
  dependency:{label:'DCR',color:'#5fb56b'},
  dataflow:{label:'Data Flow',color:'#10b981'},
  filecore:{label:'Core File',color:'#0ea5e9'},
  table:{label:'Table',color:'#ff8a65'},
  stream:{label:'Stream',color:'#9575cd'},
  workbook:{label:'Workbook',color:'#ffb74d'},
  analyticrule:{label:'Analytic',color:'#e57373'},
  huntingquery:{label:'Hunting',color:'#6366f1'},
  playbook:{label:'Playbook',color:'#ec4899'},
  watchlist:{label:'Watchlist',color:'#0ea5e9'},
  kqlfunction:{label:'KQL Function',color:'#14b8a6'},
  notebook:{label:'Notebook',color:'#6366f1'},
  functioninfra:{label:'Function Infra',color:'#4b5563'},
  deployment:{label:'Deployment',color:'#64748b'},
  externalsystem:{label:'External System',color:'#0284c7'},
  endpoint:{label:'Endpoint',color:'#0891b2'},
    serviceendpoint:{label:'Service Endpoint',color:'#dc8f00'},
  json:{label:'JSON',color:'#bdbdbd'}
};
const TYPE_ORDER=Object.keys(TYPE_META);
const EDGE_STYLE={
  'solution-corefile':{stroke:'#0284c7'},
  'solution-connector':{stroke:'#2563eb'},
  'solution-dcr':{stroke:'#0d9488'},
  'connector-dcr':{stroke:'#0f766e'},
  'connector-table':{stroke:'#c2410c'},
  'connector-stream':{stroke:'#6d28d9'},
  'dcr-table':{stroke:'#ea580c'},
  'dcr-flow':{stroke:'#059669'},
  'flow-table':{stroke:'#10b981'},
  'table-analytic':{stroke:'#991b1b'},
  'table-workbook':{stroke:'#92400e'},
  'table-hunting':{stroke:'#4338ca'},
  'solution-workbook':{stroke:'#d97706'},
  'solution-analytic':{stroke:'#b91c1c'},
  'solution-playbook':{stroke:'#be185d'},
  'solution-hunting':{stroke:'#4338ca'},
  'solution-infra':{stroke:'#334155'},
  'solution-deployment':{stroke:'#475569'},
  'solution-json':{stroke:'#64748b'},
  'system-endpoint':{stroke:'#0369a1'},
  'endpoint-connector':{stroke:'#0d9488'},
  'endpoint-dcr':{stroke:'#0f766e'},
  'solution-watchlist':{stroke:'#0891b2'},
  'solution-function':{stroke:'#0f766e'},
  'function-table':{stroke:'#0d9488'},
  'connector-serviceendpoint':{stroke:'#dc8f00'},
  'dcr-serviceendpoint':{stroke:'#b7791f'},
  'flow-serviceendpoint':{stroke:'#f59e0b'},
  'solution-notebook':{stroke:'#4f46e5'}
};

function buildDependencyGraph(art, solutionName){
  const nodes = [];
  const links = [];
  const index = new Map(); // key: type::id

  const TYPE_PRIORITY = {
    solution:100,
    connector:90,
    dependency:80,
    filecore:75,
    deployment:70,
    analyticrule:65,
    workbook:60,
    huntingquery:55,
    playbook:50,
    functioninfra:45,
    kqlfunction:45,
    notebook:35,
    watchlist:30,
    json:10,
    // low-level data nodes not collapsed by priority
    table:0, stream:0, dataflow:0, serviceendpoint:0
  };

  function add(id, type, meta = {}){
    if(!id) return;
    const key = type + '::' + id;
    const path = meta?.path || meta?.raw?.path;
    if(!index.has(key)){
      const node = { id, type, meta:{...meta, paths: path?[path]:[], originalType:type} };
      index.set(key, node);
      nodes.push(node);
    } else {
      const existing = index.get(key);
      if(path) {
        const list = existing.meta.paths || [];
        if(!list.includes(path)) list.push(path);
        existing.meta.paths = list;
      }
      Object.assign(existing.meta, meta);
    }
  }

  function link(source, target, edgeType){
    if(!source || !target) return;
    if(!links.some(l=>l.source===source && l.target===target && l.edgeType===edgeType)){
      links.push({source,target,edgeType});
    }
  }

  const root = solutionName || 'Solution';
  add(root,'solution',{});

  // Core files
  (art.coreFiles||[]).forEach(cf=>{
    add(cf.id,'filecore',cf);
    link(root,cf.id,'solution-corefile');
  });

  // DCR dependencies
  (art.dcrs||[]).forEach(d=>{
    add(d.id,'dependency',d);
    link(root,d.id,'solution-dcr');
    (d.flowsData||[]).forEach(fl=>{
      const flowId = `${d.id}::${fl.id}`;
      add(flowId,'dataflow',{ parentDcr:d.id, ...fl });
      link(d.id,flowId,'dcr-flow');
      (fl.outputTables||[]).forEach(tb=>{
        add(tb,'table',{}); link(flowId,tb,'flow-table');
      });
      (fl.streams||[]).forEach(st=>{
        add('Stream:'+st,'stream',{ parentDcr:d.id, flow:fl.id });
        link(flowId,'Stream:'+st,'dcr-flow');
      });
    });
    (d.tables||[]).forEach(tb=>{
      add(tb,'table',{}); link(d.id,tb,'dcr-table');
    });
    (d.streams||[]).forEach(st=>{
      add('Stream:'+st,'stream',{ parentDcr:d.id });
      link(d.id,'Stream:'+st,'dcr-flow');
    });
  });

  // Core dcr.json flows
  art.coreFiles.filter(cf=>cf.coreKind==='dcr').forEach(cf=>{
    (cf.flowsData||[]).forEach(fl=>{
      const flowId=`${cf.id}::${fl.id}`;
      add(flowId,'dataflow',{ parentDcr:cf.id, ...fl });
      link(cf.id,flowId,'dcr-flow');
      (fl.outputTables||[]).forEach(tb=>{
        add(tb,'table',{}); link(flowId,tb,'flow-table');
      });
      (fl.streams||[]).forEach(st=>{
        add('Stream:'+st,'stream',{ parentDcr:cf.id, flow:fl.id });
        link(flowId,'Stream:'+st,'dcr-flow');
      });
    });
  });

  // Connectors
  (art.connectors||[]).forEach(c=>{
    add(c.id,'connector',c);
    link(root,c.id,'solution-connector');
    (c.linkedDcrIds||[]).forEach(dcrId=>link(c.id,dcrId,'connector-dcr'));
    (c.tables||[]).forEach(tb=>{ add(tb,'table',{}); link(c.id,tb,'connector-table'); });
    (c.streams||[]).forEach(st=>{
      add('Stream:'+st,'stream',{ connector:c.id });
      link(c.id,'Stream:'+st,'connector-stream');
    });
  });

  // Functions
  (art.functions||[]).forEach(f=>{
    add(f.id,'kqlfunction',f); link(root,f.id,'solution-function');
    (f.tables||[]).forEach(tb=>{ add(tb,'table',{}); link(f.id,tb,'function-table'); });
  });

  // Workbooks
  (art.workbooks||[]).forEach(w=>{
    add(w.id,'workbook',w); link(root,w.id,'solution-workbook');
    (w.tables||[]).forEach(tb=>{
      if(nodes.some(n=>n.id===tb)) link(tb,w.id,'table-workbook');
    });
  });

  // Analytics
  (art.analytics||[]).forEach(a=>{
    add(a.id,'analyticrule',a); link(root,a.id,'solution-analytic');
    (a.tables||[]).forEach(tb=>{
      if(nodes.some(n=>n.id===tb)) link(tb,a.id,'table-analytic');
    });
  });

  // Hunting
  (art.hunting||[]).forEach(h=>{
    add(h.id,'huntingquery',h); link(root,h.id,'solution-hunting');
    (h.tables||[]).forEach(tb=>{
      if(nodes.some(n=>n.id===tb)) link(tb,h.id,'table-hunting');
    });
  });

  // Playbooks
  (art.playbooks||[]).forEach(p=>{
    add(p.id,'playbook',p); link(root,p.id,'solution-playbook');
  });

  // Watchlists
  (art.watchlists||[]).forEach(w=>{
    add(w.id,'watchlist',w); link(root,w.id,'solution-watchlist');
  });

  // Notebooks
  (art.notebooks||[]).forEach(n=>{
    add(n.id,'notebook',n); link(root,n.id,'solution-notebook');
  });

  // Infra
  (art.infra||[]).forEach(f=>{
    add(f.id,'functioninfra',f); link(root,f.id,'solution-infra');
  });

  // Deployment
  (art.deploy||[]).forEach(d=>{
    add(d.id,'deployment',d); link(root,d.id,'solution-deployment');
  });

  // Others (limit)
  (art.others||[]).slice(0,60).forEach(o=>{
    add(o.id,'json',o); link(root,o.id,'solution-json');
  });

  // Service Endpoints
  (art.serviceEndpoints||[]).forEach(se=>{
    const seId='SE:'+se.id;
    add(seId,'serviceendpoint',{ sources:se.sources });
    se.sources.forEach(src=>{
      const edgeType = src.type==='dcr' ? 'dcr-serviceendpoint'
                     : src.type==='connector' ? 'connector-serviceendpoint'
                     : 'solution-json';
      link(src.id,seId,edgeType);
    });
  });

  // Mark custom tables
  const builtInsLower = new Set([
    'commonsecuritylog','syslog','securityalert','securityincident','heartbeat','azureactivity',
    'signinlogs','auditlogs','officeactivity','applicationgatewayfirewalllog',
    'vmconnection','dnsevents','deviceevents','devicenetworkevents'
  ]);
  nodes.forEach(n=>{
    if(n.type==='table'){
      const idLower=n.id.toLowerCase();
      if(/_cl$|_ce$|_cf$/.test(idLower) && !builtInsLower.has(idLower)){
        n.meta.custom=true;
      }
    }
  });

  // Orphan protection
  nodes.forEach(n=>{
    if(n.type==='solution') return;
    const hasEdge = links.some(l=>l.source===n.id||l.target===n.id);
    if(!hasEdge) link(root,n.id,'solution-json');
  });

  // ----- Duplicate Collapse by ID Across Types -----
  const groupsById = nodes.reduce((m,n)=>{
    if(!m[n.id]) m[n.id]=[];
    m[n.id].push(n);
    return m;
  },{});
  const removeSet = new Set();
  Object.entries(groupsById).forEach(([id, group])=>{
    if(group.length<=1) return;
    // Preserve low-level data nodes as-is
    if(group.every(g=>TYPE_PRIORITY[g.type]===0)) return;

    // Choose representative
    group.sort((a,b)=>TYPE_PRIORITY[b.type]-TYPE_PRIORITY[a.type]);
    const rep = group[0];

    for(let i=1;i<group.length;i++){
      const dup = group[i];
      // Merge meta
      const repMeta = rep.meta||{};
      const dupMeta = dup.meta||{};
      // Merge paths
      repMeta.paths = [...new Set([...(repMeta.paths||[]), ...(dupMeta.paths||[])])];
      // Merge endpoints
      repMeta.endpoints = [...new Set([...(repMeta.endpoints||[]), ...(dupMeta.endpoints||[])])];
      // Merge tables/streams if present
      if(dupMeta.tables) repMeta.tables = [...new Set([...(repMeta.tables||[]), ...dupMeta.tables])];
      if(dupMeta.streams) repMeta.streams = [...new Set([...(repMeta.streams||[]), ...dupMeta.streams])];
      // Mark consolidated
      repMeta.consolidated = true;
      removeSet.add(dup);
    }
  });

  // Rewrite links from removed nodes to representative
  if(removeSet.size){
    links.forEach(l=>{
      const removedSource = [...removeSet].find(r=>r.id===l.source);
      const removedTarget = [...removeSet].find(r=>r.id===l.target);
      if(removedSource){
        // find representative with same id
        const rep = nodes.find(n=>n.id===removedSource.id && !removeSet.has(n));
        if(rep) l.source = rep.id;
      }
      if(removedTarget){
        const rep = nodes.find(n=>n.id===removedTarget.id && !removeSet.has(n));
        if(rep) l.target = rep.id;
      }
    });
    // Deduplicate links after rewrite
    const unique = [];
    links.forEach(l=>{
      if(!unique.some(u=>u.source===l.source && u.target===l.target && u.edgeType===l.edgeType)){
        unique.push(l);
      }
    });
    links.length=0; links.push(...unique);
    // Remove duplicate nodes
    const filtered = nodes.filter(n=>!removeSet.has(n));
    nodes.length=0; nodes.push(...filtered);
  }

  // Solution summary counts
  const solNode = nodes.find(n=>n.type==='solution');
  if(solNode){
    solNode.meta.counts = {
      connectors:(art.connectors||[]).length,
      dcrs:(art.dcrs||[]).length,
      workbooks:(art.workbooks||[]).length,
      analytics:(art.analytics||[]).length,
      playbooks:(art.playbooks||[]).length,
      hunting:(art.hunting||[]).length,
      watchlists:(art.watchlists||[]).length,
      functions:(art.functions||[]).length,
      notebooks:(art.notebooks||[]).length,
      coreFiles:(art.coreFiles||[]).length,
      serviceEndpoints:(art.serviceEndpoints||[]).length
    };
  }

  return { nodes, links };
}

function buildArchitectureGraph(art, meta, analysis){
  const g = { nodes:[], links:[] };
  const add = (id, type, metaObj={}) => {
    if(!id) return;
    if(!g.nodes.some(n=>n.id===id)) g.nodes.push({ id, type, meta: metaObj });
  };
  const link = (s,t,e) => {
    if(!s||!t) return;
    if(!g.links.some(l=>l.source===s && l.target===t && l.edgeType===e)){
      g.links.push({ source:s, target:t, edgeType:e });
    }
  };

  // Single root declaration (fix for duplicate 'root')
  const root = meta?.solutionName || 'Solution';
  add(root,'solution',{ archType: analysis?.type });

  /* Endpoint hosts (group into externals + endpoint nodes) */
  const endpointHosts = new Map();
  function collectEndpoints(list){
    (list||[]).forEach(a => (a.endpoints||[]).forEach(ep =>{
      const h = ep.toLowerCase();
      if(!endpointHosts.has(h)){
        endpointHosts.set(h, {
          id: h,
            host: h,
            connectors: new Set(),
            dcrs: new Set()
        });
      }
    }));
  }
  collectEndpoints(art.connectors);
  collectEndpoints(art.coreFiles.filter(cf=>cf.coreKind==='dcr'));
  collectEndpoints(art.dcrs);

  function rootDomain(host){
    const parts = host.split('.');
    if(parts.length <= 2) return host;
    return parts.slice(-2).join('.');
  }

  const externals = new Map();
  endpointHosts.forEach((_, host)=>{
    const rd = rootDomain(host);
    if(!externals.has(rd)) externals.set(rd,{ id: rd, hosts: new Set() });
    externals.get(rd).hosts.add(host);
  });

  externals.forEach(sys => add(sys.id,'externalsystem',{ hostCount: sys.hosts.size }));
  endpointHosts.forEach(ep => add(ep.id,'endpoint'));

  /* Connectors */
  (art.connectors||[]).forEach(c=>{
    add(c.id,'connector',c);
    link(root,c.id,'solution-connector');
    (c.endpoints||[]).forEach(ep=>{
      const host = ep.toLowerCase();
      link(c.id, host,'endpoint-connector');
    });
    (c.tables||[]).forEach(tb=>{
      add(tb,'table',{}); link(c.id,tb,'connector-table');
    });
  });

  /* DCR dependencies */
  (art.dcrs||[]).forEach(d=>{
    add(d.id,'dependency',d);
    link(root,d.id,'solution-dcr');
    (d.flowsData||[]).forEach(fl=>{
      const flowId = `${d.id}::${fl.id}`;
      add(flowId,'dataflow',{ parentDcr:d.id, ...fl });
      link(d.id,flowId,'dcr-flow');
      (fl.outputTables||[]).forEach(tb=>{
        add(tb,'table',{}); link(flowId,tb,'flow-table');
      });
      (fl.streams||[]).forEach(st=>{
        const stId='Stream:'+st;
        add(stId,'stream',{ parentDcr:d.id, flow:fl.id });
        link(flowId,stId,'dcr-flow');
      });
    });
    (d.tables||[]).forEach(tb=>{
      add(tb,'table',{}); link(d.id,tb,'dcr-table');
    });
  });

  /* Core DCR flows */
  art.coreFiles.filter(cf=>cf.coreKind==='dcr').forEach(cf=>{
    add(cf.id,'filecore',cf);
    link(root,cf.id,'solution-corefile');
    (cf.flowsData||[]).forEach(fl=>{
      const flowId = `${cf.id}::${fl.id}`;
      add(flowId,'dataflow',{ parentDcr:cf.id, ...fl });
      link(cf.id,flowId,'dcr-flow');
      (fl.outputTables||[]).forEach(tb=>{
        add(tb,'table',{}); link(flowId,tb,'flow-table');
      });
      (fl.streams||[]).forEach(st=>{
        const stId='Stream:'+st;
        add(stId,'stream',{ parentDcr:cf.id, flow:fl.id });
        link(flowId,stId,'dcr-flow');
      });
    });
  });

  /* Other core files (excluding dcr already added) */
  art.coreFiles.forEach(cf=>{
    if(cf.coreKind==='dcr') return;
    add(cf.id,'filecore',cf);
    link(root,cf.id,'solution-corefile');
  });

  /* Service Endpoints (if aggregated) */
  (art.serviceEndpoints||[]).forEach(se=>{
    if(!se?.id || !se.sources?.length) return;
    const seId = 'SE:'+se.id;
    add(seId,'serviceendpoint',{ sources: se.sources, count: se.sources.length });
    se.sources.forEach(src=>{
      let edgeType = 'solution-json';
      if(src.type === 'dcr') edgeType = 'dcr-serviceendpoint';
      else if(src.type === 'connector') edgeType = 'connector-serviceendpoint';
      link(src.id, seId, edgeType);
    });
    link(root,seId,'solution-json');
  });

  /* Functions */
  (art.functions||[]).forEach(f=>{
    add(f.id,'kqlfunction',f); link(root,f.id,'solution-function');
    (f.tables||[]).forEach(tb=>{
      add(tb,'table',{}); link(f.id,tb,'function-table');
    });
  });

  /* Workbooks / Analytics / Hunting / Playbooks / Watchlists / Notebooks */
  (art.workbooks||[]).forEach(w=>{
    add(w.id,'workbook',w); link(root,w.id,'solution-workbook');
    (w.tables||[]).forEach(tb=>{
      if(g.nodes.some(n=>n.id===tb)) link(tb,w.id,'table-workbook');
    });
  });
  (art.analytics||[]).forEach(a=>{
    add(a.id,'analyticrule',a); link(root,a.id,'solution-analytic');
    (a.tables||[]).forEach(tb=>{
      if(g.nodes.some(n=>n.id===tb)) link(tb,a.id,'table-analytic');
    });
  });
  (art.hunting||[]).forEach(h=>{
    add(h.id,'huntingquery',h); link(root,h.id,'solution-hunting');
    (h.tables||[]).forEach(tb=>{
      if(g.nodes.some(n=>n.id===tb)) link(tb,h.id,'table-hunting');
    });
  });
  (art.playbooks||[]).forEach(p=>{
    add(p.id,'playbook',p); link(root,p.id,'solution-playbook');
  });
  (art.watchlists||[]).forEach(w=>{
    add(w.id,'watchlist',w); link(root,w.id,'solution-watchlist');
  });
  (art.notebooks||[]).forEach(n=>{
    add(n.id,'notebook',n); link(root,n.id,'solution-notebook');
  });

  /* Infra / Deploy / Others */
  (art.infra||[]).forEach(f=>{
    add(f.id,'functioninfra',f); link(root,f.id,'solution-infra');
  });
  (art.deploy||[]).forEach(d=>{
    add(d.id,'deployment',d); link(root,d.id,'solution-deployment');
  });
  (art.others||[]).slice(0,60).forEach(o=>{
    add(o.id,'json',o); link(root,o.id,'solution-json');
  });

  /* External system → endpoint host links */
  endpointHosts.forEach((ep, host)=>{
    const rd = rootDomain(host);
    link(rd, host,'system-endpoint');
  });
  externals.forEach(sys=> link(root, sys.id,'solution-json'));

  return g;
}
/* ================= RENDERING ================= */
let ZOOM_CTRL=null;
function setupZoom(){
  if(!ensureD3())return;
  const svg=d3.select('#viz');
  const zoom=d3.zoom().scaleExtent([0.08,5]).on('zoom',e=>{
    STATE.zoom=e.transform;
    d3.select('#zoomLayer').attr('transform',e.transform);
  });
  svg.call(zoom);
  return zoom;
}
function fitView(duration=600){
  if(!ensureD3())return;
  const nodes=STATE.graph.nodes; if(!nodes.length)return;
  const svgEl=$('#viz'); const w=svgEl.clientWidth, h=svgEl.clientHeight;
  const xs=nodes.map(n=>n.x||0), ys=nodes.map(n=>n.y||0);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const dx=maxX-minX||10, dy=maxY-minY||10;
  const scale=Math.min(3,0.9/Math.max(dx/w,dy/h));
  const t=d3.zoomIdentity.translate((w/2)-(minX+dx/2)*scale,(h/2)-(minY+dy/2)*scale).scale(scale);
  d3.select('#viz').transition().duration(duration).call(ZOOM_CTRL.transform,t);
  STATE.zoom=t;
}

function buildTooltip(){
  const tip=d3.select('#tooltip');
  return {
    show(evt,d){
      const m=d.meta||{};
      const L=[];
      L.push(`<div><b>${(TYPE_META[d.type]?.label)||d.type}</b> – ${escapeHtml(d.id)}</div>`);
      if(d.type==='solution' && m.counts){
        const c=m.counts;
        L.push(`<div><b>Artifacts:</b> Conn ${c.connectors} DCR ${c.dcrs} Fn ${c.functions} Wkb ${c.workbooks}</div>`);
      }
      if(d.type==='filecore'){
        if(m.coreKind==='mainTemplate'){
          const rc=m.resourceCounts||{};
            L.push(`<div><b>Resources:</b> ${rc.total} (DC:${rc.dataConnectors} AR:${rc.analyticRules} WB:${rc.workbooks} PB:${rc.playbooks})</div>`);
        }
        if(m.coreKind==='dcr') L.push(`<div><b>DCR Flows:</b> ${m.dataFlows||0} Streams:${m.streamCount||0}</div>`);
      }
      if(d.type==='dataflow'){
        L.push(`<div><b>Parent DCR:</b> ${escapeHtml(m.parentDcr||'')}</div>`);
        L.push(`<div><b>Streams:</b> ${(m.streams||[]).join(', ')||'—'}</div>`);
        if(m.outputTables?.length) L.push(`<div><b>Outputs:</b> ${m.outputTables.join(', ')}</div>`);
        L.push(`<div><b>Transform:</b> ${m.hasTransform?`${m.transformLines} lines`:'None'}</div>`);
      }
      if(d.type==='connector'){
        if(m.mechanism) L.push(`<div><b>Mechanism:</b> ${escapeHtml(m.mechanism)}</div>`);
        if(m.kindCategory) L.push(`<div><b>Kind:</b> ${escapeHtml(m.kindCategory)}</div>`);
        if(m.tables?.length) L.push(`<div><b>Tables:</b> ${m.tables.join(', ')}</div>`);
        if(m.endpoints?.length) L.push(`<div><b>Endpoints:</b> ${m.endpoints.join(', ')}</div>`);
      }
      if(['workbook','analyticrule','huntingquery'].includes(d.type)){
        if(m.queryMetrics) L.push(`<div><b>Query:</b> ${m.queryMetrics.lines} lines</div>`);
        if(m.tables?.length) L.push(`<div><b>Tables:</b> ${m.tables.join(', ')}</div>`);
        if(m.severity) L.push(`<div><b>Severity:</b> ${m.severity}</div>`);
      }
      if(d.type==='playbook') L.push(`<div><b>Triggers:</b> ${m.triggers||0} Actions:${m.actions||0}</div>`);
      if(d.type==='kqlfunction'){
        if(m.tables?.length) L.push(`<div><b>Tables:</b> ${m.tables.join(', ')}</div>`);
        if(m.queryMetrics) L.push(`<div><b>KQL:</b> ${m.queryMetrics.lines} lines</div>`);
      }
      if(d.type==='notebook' && m.cellCount!=null) L.push(`<div><b>Cells:</b> ${m.cellCount}</div>`);
      if(d.type==='externalsystem') L.push(`<div><b>Hosts:</b> ${m.hostCount||0}</div>`);
      if(d.type==='endpoint') L.push('<div>Endpoint host</div>');
      tip.html(L.join('')).style('left',(evt.clientX+14)+'px').style('top',(evt.clientY+14)+'px').style('opacity',1);
    },
    hide(){ tip.style('opacity',0); }
  };
}

const NODE_LABEL_CFG={maxLines:7,minWidth:120,maxWidth:280,lineChars:24};
function nodeLines(d){
  const m = d.meta || {};
  const lines = [];
  const base = d.meta?.displayId || d.id;
  const cfg = NODE_LABEL_CFG || { maxLines: 8, lineChars: 28 };
  function trunc(s, max = cfg.lineChars){ 
    if(s == null) return ''; 
    s = String(s); 
    return s.length <= max ? s : s.slice(0, max - 1) + '…'; 
  }
  function push(val){ if(val) lines.push(val); }

  // ---------- Solution ----------
  if(d.type === 'solution'){
    push(trunc(d.id, 40));
    if(m.archType) push(`Arch: ${m.archType}`);
    if(m.counts){
      const c = m.counts;
      // Show primary artifact counts
      push(`Conn:${c.connectors} DCR:${c.dcrs} SE:${c.serviceEndpoints}`);
      // Secondary summary (only if space)
      if(lines.length < cfg.maxLines - 1){
        push(`Analytic:${c.analytics} Wkbk:${c.workbooks} Ply:${c.playbooks}`);
      }
    }
    if(m.publisher) push(trunc(m.publisher, 32));
  }

  // ---------- Connector ----------
  else if(d.type === 'connector'){
    push(trunc(d.id, 40));
    if(m.ingestionType) push(m.ingestionType);
    const tables = Array.isArray(m.tables)?m.tables.length:0;
    const streams = Array.isArray(m.streams)?m.streams.length:0;
    if(tables || streams) push(`T:${tables} S:${streams}`);
    if(m.hasEventApiPoller) push('Event API Poller');
    if(m.linkedDcrIds && m.linkedDcrIds.length){
      push(`DCRs:${m.linkedDcrIds.length}`);
    }
    if(m.publisher) push(trunc(m.publisher, 28));
  }

  // ---------- Dependency (DCR-likes) ----------
  else if(d.type === 'dependency'){
    push(trunc(d.id, 38));
    const flows = Array.isArray(m.flowsData)?m.flowsData.length:0;
    const tables = Array.isArray(m.tables)?m.tables.length:0;
    const streams = Array.isArray(m.streams)?m.streams.length:0;
    push(`Flows:${flows} T:${tables} S:${streams}`);
  }

  // ---------- Core File ----------
  else if(d.type === 'filecore'){
    push(trunc(d.id, 42));
    if(m.coreKind) push(m.coreKind);
    if(m.coreKind === 'dcr'){
      push(`Flows:${m.dataFlows||0} Streams:${m.streamCount||0}`);
    } else if(m.coreKind === 'mainTemplate' && m.resourceCounts){
      const rc = m.resourceCounts;
      push(`dc:${rc.dataConnectors} ar:${rc.analyticRules} wb:${rc.workbooks}`);
    } else if(m.coreKind === 'pollerConfig' && m.schedule){
      push(trunc(m.schedule, 28));
    }
  }

  // ---------- Data Flow ----------
  else if(d.type === 'dataflow'){
    push(`Flow:${m.id||d.id}`);
    const sl = m.transformLines || 0;
    const ot = Array.isArray(m.outputTables)?m.outputTables.length:0;
    push(`Lines:${sl} OutT:${ot}`);
    if(Array.isArray(m.streams) && m.streams.length){
      push(`Streams:${m.streams.length}`);
    }
    if(m.hasTransform) push('Transform');
  }

  // ---------- Stream ----------
  else if(d.type === 'stream'){
    push(trunc(d.id.replace(/^Stream:/,''), 34));
    if(m.parentDcr) push(`DCR:${trunc(m.parentDcr, 20)}`);
    if(m.flow) push(`Flow:${m.flow}`);
  }

  // ---------- Table ----------
  else if(d.type === 'table'){
    push(trunc(d.id, 34));
    if(m.custom) push('Custom');
  }

  // ---------- Workbook ----------
  else if(d.type === 'workbook'){
    push(trunc(d.id, 40));
    if(m.tables && m.tables.length) push(`Tables:${m.tables.length}`);
    if(m.description) push(trunc(m.description, 30));
  }

  // ---------- Analytic Rule ----------
  else if(d.type === 'analyticrule'){
    push(trunc(d.id, 42));
    if(m.severity) push(`Sev:${m.severity}`);
    if(m.tables && m.tables.length) push(`Tables:${m.tables.length}`);
    if(m.tactics) push(trunc(m.tactics, 30));
  }

  // ---------- Hunting Query ----------
  else if(d.type === 'huntingquery'){
    push(trunc(d.id, 42));
    if(m.tables && m.tables.length) push(`Tables:${m.tables.length}`);
    if(m.queryMetrics) push(`Lines:${m.queryMetrics.lines}`);
  }

  // ---------- Playbook ----------
  else if(d.type === 'playbook'){
    push(trunc(d.id, 42));
    if(m.triggers != null) push(`Trig:${m.triggers}`);
    if(m.actions != null) push(`Act:${m.actions}`);
  }

  // ---------- Watchlist ----------
  else if(d.type === 'watchlist'){
    push(trunc(d.id, 42));
    if(m.description) push(trunc(m.description, 32));
  }

  // ---------- KQL Function ----------
  else if(d.type === 'kqlfunction'){
    push(trunc(d.id, 42));
    if(m.tables && m.tables.length) push(`Tables:${m.tables.length}`);
    if(m.queryMetrics) push(`Lines:${m.queryMetrics.lines}`);
  }

  // ---------- Notebook ----------
  else if(d.type === 'notebook'){
    push(trunc(d.id, 42));
    if(m.cellCount != null) push(`Cells:${m.cellCount}`);
  }

  // ---------- Function Infra ----------
  else if(d.type === 'functioninfra'){
    push(trunc(d.id, 42));
    if(m.bindingsCount) push(`Bindings:${m.bindingsCount}`);
  }

  // ---------- Deployment ----------
  else if(d.type === 'deployment'){
    push(trunc(d.id, 42));
    if(m.resourceCount != null) push(`Resources:${m.resourceCount}`);
  }

  // ---------- Service Endpoint ----------
  else if(d.type === 'serviceendpoint'){
    const name = d.id.replace(/^SE:/,'');
    push(trunc(name, 44));
    if(m.sources && m.sources.length){
      // Distill counts by type
      const counts = m.sources.reduce((acc,s)=>{
        acc[s.type] = (acc[s.type]||0)+1; return acc;
      },{});
      const parts = Object.entries(counts).map(([k,v])=>`${k}:${v}`).slice(0,3).join(' ');
      push(parts);
    }
  }

  // ---------- Endpoint (host) ----------
  else if(d.type === 'endpoint'){
    push(trunc(d.id, 46));
  }

  // ---------- External System ----------
  else if(d.type === 'externalsystem'){
    push(trunc(d.id, 46));
    if(m.hostCount != null) push(`Hosts:${m.hostCount}`);
  }

  // ---------- Generic JSON ----------
  else if(d.type === 'json'){
    push(trunc(d.id, 46));
  }

  // Safety: limit lines
  if(lines.length > (cfg.maxLines || 8)){
    const keep = lines.slice(0, (cfg.maxLines || 8) - 1);
    keep.push('…');
    return keep;
  }
  return lines;
}
function renderGraph(preserve=false){
  if(!ensureD3())return;
  const nodes=STATE.graph.nodes, links=STATE.graph.links;
  const svg=d3.select('#viz'), layer=d3.select('#zoomLayer');
  layer.selectAll('*').remove();
  const w=svg.node().clientWidth||1400, h=svg.node().clientHeight||900;
  const tip=buildTooltip();

  const defs=layer.append('defs');
  defs.append('marker')
    .attr('id','arrow')
    .attr('viewBox','0 -5 10 10')
    .attr('refX',18).attr('refY',0)
    .attr('markerWidth',6).attr('markerHeight',6)
    .attr('orient','auto')
    .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','#64748b');

  const linkG=layer.append('g').attr('class','links').selectAll('g').data(links).enter().append('g');
  const linkPath=linkG.append('path')
    .attr('class','graph-link')
    .attr('stroke',l=>EDGE_STYLE[l.edgeType]?.stroke||'#64748b')
    .attr('stroke-opacity',.55)
    .attr('stroke-width',1.3)
    .attr('fill','none')
    .attr('marker-end','url(#arrow)');
  let edgeLabels=null;
  if(STATE.showEdgeLabels){
    edgeLabels=linkG.append('text')
      .attr('class','edge-label')
      .attr('text-anchor','middle')
      .text(l=>l.edgeType);
  }

  const nodeG=layer.append('g').attr('class','nodes')
    .selectAll('g').data(nodes,d=>d.id).enter().append('g')
    .attr('class','node-group')
    .on('mouseover',tip.show)
    .on('mouseout',tip.hide)
    .on('click',(e,d)=>{
      highlightNode(d.id);
      STATE.highlighted=d.id;
      showArtifactDetails(d);
      tip.show(e,d);
    })
    .call(d3.drag()
      .on('start',(e,d)=>{ d.fx=d.x; d.fy=d.y; if(STATE.simulation) STATE.simulation.alphaTarget(.25).restart(); })
      .on('drag',(e,d)=>{ d.fx=e.x; d.fy=e.y; })
      .on('end',(e,d)=>{ if(STATE.simulation && STATE.layoutMode==='force'){ d.fx=null; d.fy=null; STATE.simulation.alphaTarget(0); }})
    );

  nodeG.each(function(d){
    const g=d3.select(this);
    const lines=nodeLines(d);
    const longest=lines.reduce((m,l)=>Math.max(m,l.length),0);
    const charPx=6.6;
    let width=Math.min(NODE_LABEL_CFG.maxWidth,Math.max(NODE_LABEL_CFG.minWidth,longest*charPx+26));
    const height=Math.max(44,lines.length*14+16);
    g.append('rect')
      .attr('width',width).attr('height',height)
      .attr('x',-width/2).attr('y',-height/2)
      .attr('rx',10)
      .attr('fill',TYPE_META[d.type]?.color||'#94a3b8')
      .attr('stroke','#1e293b')
      .attr('stroke-width',1.15);
    lines.forEach((ln,i)=>{
      const maxCharsLine=Math.floor((width-22)/charPx);
      const txt=ln.length>maxCharsLine?ln.slice(0,maxCharsLine-1)+'…':ln;
      g.append('text')
        .attr('text-anchor','middle')
        .attr('y',(-height/2+16)+i*14)
        .attr('font-size',i===0?12:10.5)
        .attr('font-weight',i===0?600:400)
        .attr('fill','#1f2937')
        .text(txt);
    });
  });

  function tick(){
    nodeG.attr('transform',d=>`translate(${d.x},${d.y})`);
    linkPath.attr('d',l=>{
      const s=nodes.find(n=>n.id===l.source)||l.source;
      const t=nodes.find(n=>n.id===l.target)||l.target;
      if(!s||!t) return '';
      const dx=t.x-s.x, dy=t.y-s.y;
      const dr=Math.sqrt(dx*dx+dy*dy)*1.05;
      return `M${s.x},${s.y}A${dr},${dr} 0 0,1 ${t.x},${t.y}`;
    });
    if(edgeLabels){
      edgeLabels
        .attr('x',l=>{
          const s=nodes.find(n=>n.id===l.source)||l.source;
          const t=nodes.find(n=>n.id===l.target)||l.target;
          return (s.x+t.x)/2;
        })
        .attr('y',l=>{
          const s=nodes.find(n=>n.id===l.source)||l.source;
          const t=nodes.find(n=>n.id===l.target)||l.target;
          return (s.y+t.y)/2;
        });
    }
    const pad=60;
    nodes.forEach(n=>{
      n.x=Math.max(pad,Math.min((w-pad),n.x));
      n.y=Math.max(pad,Math.min((h-pad),n.y));
    });
  }

  if(STATE.layoutMode==='force'){
    const sim=d3.forceSimulation(nodes)
      .force('link',d3.forceLink(links).id(d=>d.id).distance(150).strength(.9))
      .force('charge',d3.forceManyBody().strength(-420))
      .force('collide',d3.forceCollide().radius(70))
      .force('center',d3.forceCenter(w/2,h/2))
      .on('tick',tick)
      .on('end',()=>{ fitView(400); });
    STATE.simulation=sim;
  } else if(STATE.layoutMode==='radial'){
    const grouped=TYPE_ORDER.map(t=>nodes.filter(n=>n.type===t)).filter(g=>g.length);
    const cx=w/2, cy=h/2;
    const ringGap=Math.min(w,h)/(2*(grouped.length+1));
    grouped.forEach((arr,i)=>{
      const r=ringGap*(i+1);
      arr.forEach((n,idx)=>{
        const angle=(idx/arr.length)*Math.PI*2;
        n.x=cx+r*Math.cos(angle); n.y=cy+r*Math.sin(angle);
      });
    });
    tick(); STATE.simulation=null;
  } else if(STATE.layoutMode==='grid'){
    const groups=TYPE_ORDER.map(t=>nodes.filter(n=>n.type===t)).filter(g=>g.length);
    let yOff=80;
    groups.forEach(g=>{
      const cols=Math.ceil(Math.sqrt(g.length));
      const cellW=220, cellH=130;
      g.forEach((n,i)=>{
        const col=i%cols, row=(i/cols)|0;
        n.x=140+col*cellW; n.y=yOff+row*cellH;
      });
      yOff+=Math.ceil(g.length/cols)*cellH+90;
    });
    tick(); STATE.simulation=null;
  } else if(STATE.layoutMode==='architecture'){
    const layers=[
      nodes.filter(n=>n.type==='solution'),
      nodes.filter(n=>n.type==='externalsystem'),
      nodes.filter(n=>n.type==='endpoint'),
      nodes.filter(n=>n.type==='connector'),
      nodes.filter(n=>n.type==='dependency'),
      nodes.filter(n=>n.type==='dataflow'),
      nodes.filter(n=>n.type==='kqlfunction'),
      nodes.filter(n=>n.type==='table'),
      nodes.filter(n=>['analyticrule','workbook','huntingquery','playbook','watchlist','notebook'].includes(n.type))
    ].filter(a=>a.length);
    const layerGap=150;
    const startX=140;
    layers.forEach((layerNodes,i)=>{
      const y=120+i*layerGap;
      const cols=Math.max(1,Math.ceil(Math.sqrt(layerNodes.length)));
      const colWidth=220;
      layerNodes.forEach((n,idx)=>{
        const col=idx%cols, row=(idx/cols)|0;
        n.x=startX+col*colWidth;
        n.y=y+row*110;
      });
    });
    tick(); STATE.simulation=null;
  } else {
    tick(); STATE.simulation=null;
  }
  if(!preserve) fitView(0);
}

function highlightNode(id){
  if(!ensureD3())return;
  const nodeSel=d3.select('#zoomLayer').selectAll('.node-group');
  const linkSel=d3.select('#zoomLayer').selectAll('.graph-link');
  if(!id){
    nodeSel.selectAll('rect').attr('opacity',1).attr('stroke-width',1.15);
    linkSel.attr('stroke-opacity',.55).attr('stroke-width',1.3);
    STATE.highlighted=null; return;
  }
  const connected=new Set([id]);
  STATE.graph.links.forEach(l=>{
    if(l.source===id) connected.add(l.target);
    if(l.target===id) connected.add(l.source);
  });
  nodeSel.selectAll('rect')
    .attr('opacity',d=>connected.has(d.id)?1:0.18)
    .attr('stroke-width',d=>d.id===id?3:1.15);
  linkSel
    .attr('stroke-opacity',l=>(l.source===id||l.target===id)?1:0.08)
    .attr('stroke-width',l=>(l.source===id||l.target===id)?3:1.3);
}

/* ================= PANELS ================= */
function buildTypeFilters(){
  const cont=$('#filterTypes'); cont.innerHTML='';
  const present=new Set(STATE.fullGraph.nodes.map(n=>n.type));
  TYPE_ORDER.forEach(t=>{
    if(!present.has(t)) return;
    const label=document.createElement('label');
    label.style.display='flex'; label.style.alignItems='center'; label.style.gap='4px';
    label.innerHTML=`<input type="checkbox" data-type-filter="${t}" checked /> ${(TYPE_META[t]?.label)||t}`;
    cont.appendChild(label);
  });
  $$('[data-type-filter]').forEach(cb=>cb.addEventListener('change',applyFilters));
}
function applyFilters(){
  if(!STATE.fullGraph)return;
  const active=new Set($$('[data-type-filter]:checked').map(cb=>cb.getAttribute('data-type-filter')));
  let nodes=STATE.fullGraph.nodes.filter(n=>active.has(n.type));
  if(!STATE.showIsolated){
    const ids=new Set(nodes.map(n=>n.id));
    const links=STATE.fullGraph.links.filter(l=>ids.has(l.source)&&ids.has(l.target));
    const connected=new Set(); links.forEach(l=>{connected.add(l.source);connected.add(l.target);});
    nodes=nodes.filter(n=>connected.has(n.id)||n.type==='solution');
  }
  const ids=new Set(nodes.map(n=>n.id));
  const links=STATE.fullGraph.links.filter(l=>ids.has(l.source)&&ids.has(l.target));
  STATE.graph={nodes:JSON.parse(JSON.stringify(nodes)),links:JSON.parse(JSON.stringify(links))};
  renderGraph(true);
  if(STATE.highlighted) highlightNode(STATE.highlighted);
  buildLegend();
}
function buildLegend(){
  const div=$('#legend'); div.innerHTML='';
  const present=new Set(STATE.graph.nodes.map(n=>n.type));
  TYPE_ORDER.forEach(t=>{
    if(!present.has(t)) return;
    const row=document.createElement('div');
    row.style.display='flex'; row.style.alignItems='center'; row.style.gap='6px';
    row.innerHTML=`<span style="width:14px;height:14px;border-radius:4px;background:${TYPE_META[t].color};display:inline-block;border:1px solid #1e293b22"></span><span>${TYPE_META[t].label}</span>`;
    div.appendChild(row);
  });
}

function rebuildArchitectureSignals(artifacts){
  const result={
    ccfSignals:new Set(),
    httpSignals:new Set(),
    evidence:[],
    opinsightsUris:new Set()  // collected full URIs
  };
  if(!artifacts) return result;

  // Generic deep scan for opinsights URIs
  function walk(node){
    if(!node) return;
    if(Array.isArray(node)){
      node.forEach(walk);
      return;
    }
    if(typeof node==='object'){
      for(const k in node){
        const v=node[k];
        if(typeof v==='string'){
          const lower=v.toLowerCase();
          if(lower.includes('opinsights.azure.com') || lower.includes('.ods.opinsights.azure.com')){
            result.opinsightsUris.add(v.trim());
            // Capture explicit property semantics
            if(/loganalyticsuri|loganalyticsurl/.test(k.toLowerCase())){
              result.evidence.push(`Found ${k}="${v}" (HTTP ingestion endpoint)`);
            }
          }
        }
        walk(v);
      }
    }
  }

  // Scan core files for endpoints and CCF hints
  (artifacts.coreFiles||[]).forEach(cf=>{
    const raw=cf.raw||{};
    walk(raw);
    const txt=JSON.stringify(raw).toLowerCase();
    if(/workspaceid/.test(txt) && /sharedkey/.test(txt)){
      result.httpSignals.add('workspaceId+sharedKey');
      result.evidence.push(`Core file "${cf.id||cf.path}": workspaceId + sharedKey pair (HTTP)`);
    }
    if(/dcrconfig/.test(txt)){
      result.ccfSignals.add('dcrConfig');
      result.evidence.push(`Core file "${cf.id||cf.path}": dcrConfig reference (CCF)`);
    }
  });

  // Scan connectors
  (artifacts.connectors||[]).forEach(conn=>{
    const raw=conn.raw||{};
    walk(raw);
    const txt=JSON.stringify(raw).toLowerCase();
    const mech=(conn.mechanism||'').toLowerCase();

    // CCF signals
    if(raw?.properties?.dcrConfig){
      result.ccfSignals.add('dcrConfig');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": properties.dcrConfig present (CCF)`);
    }
    if(/restapipoller|apipolling/.test(txt)){
      result.ccfSignals.add('apiPoller');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": restApiPoller/apipolling keyword (CCF)`);
    }
    if(/codeless/.test(txt)){
      result.ccfSignals.add('codeless');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": "codeless" keyword (CCF)`);
    }
    if(Array.isArray(conn.streams) && conn.streams.length){
      result.ccfSignals.add('streams');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": defines ${conn.streams.length} stream(s) (CCF)`);
    }

    // HTTP signals
    if(/workspaceid/.test(txt)&&/sharedkey/.test(txt)){
      result.httpSignals.add('workspaceId+sharedKey');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": workspaceId + sharedKey found (HTTP)`);
    }
    if(/x-ms-signature/.test(txt)){
      result.httpSignals.add('x-ms-signature');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": x-ms-signature header (HTTP)`);
    }
    if(/opinsights\.azure\.com/.test(txt)){
      result.httpSignals.add('opinsights-endpoint');
      // evidence for presence already added via walk if it hit a property value
      if(![...result.opinsightsUris].some(u=>txt.includes(u.toLowerCase()))){
        result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": opinsights ingestion endpoint string (HTTP)`);
      }
    }
    if(/datacollector/.test(txt)||mech.includes('http data collector')){
      result.httpSignals.add('data-collector');
      result.evidence.push(`Connector "${conn.id||conn.name||'unnamed'}": Data Collector mechanism (HTTP)`);
    }
  });

  return result;
}

function buildArchitectureReasoning(arch, artifacts){
  if(!arch || !arch.type) return 'No classification yet.';
  const { ccfSignals, httpSignals, opinsightsUris } = rebuildArchitectureSignals(artifacts);
  const uriList=[...opinsightsUris];

  function appendUris(base){
    if(!uriList.length) return base;
    const shown=uriList.slice(0,2).join(', ');
    const more=uriList.length>2?` (+${uriList.length-2} more)`:'';
    return `${base}; Endpoint(s): ${shown}${more}`;
  }

  if(arch.type==='CCF'){
    if(ccfSignals.size===0) return 'CCF (no explicit CCF signals captured)';
    const map={
      dcrConfig:'DCR configuration present',
      apiPoller:'REST API poller keywords',
      codeless:'Codeless connector metadata',
      streams:'Defined ingestion streams'
    };
    let reason='CCF because: '+[...ccfSignals].map(s=>map[s]||s).join('; ');
    if(!httpSignals.size) reason+='; No HTTP Data Collector indicators';
    return appendUris(reason);
  }
  if(arch.type.startsWith('HTTP')){
    if(httpSignals.size===0) return 'HTTP Data Collector API (no explicit HTTP signals captured)';
    const map={
      'workspaceId+sharedKey':'Shared key workspace auth',
      'x-ms-signature':'Signed requests (x-ms-signature)',
      'opinsights-endpoint':'Legacy opinsights ingestion endpoint',
      'data-collector':'Data Collector mechanism'
    };
    let reason='HTTP Data Collector API because: '+[...httpSignals].map(s=>map[s]||s).join('; ');
    if(!ccfSignals.size) reason+='; No CCF indicators';
    return appendUris(reason);
  }
  return appendUris('Unknown: no decisive CCF or HTTP ingestion signals');
}


/* ===== REPLACEMENT: analyzeSolutionArchitecture (adds Legacy & Unknown) ===== */
function analyzeSolutionArchitecture(art){
  if(!art) return {
    type:'Unknown',
    connectors:[],
    counts:{ccf:0,http:0,legacy:0,total:0},
    core:{},
    reasoning:'No artifacts loaded.',
    evidence:'',
    reasoningLines:['No artifacts.'],
    evidenceLines:[],
    findings:[],
    signalsCatalog:{ccf:[],http:[],legacy:[],core:[]}
  };

  const prettyJson = v => { try{return JSON.stringify(v,null,2);}catch{return'';} };
  const files = Array.isArray(art.files)?art.files:[];
  const fileMap = new Map();
  files.forEach(f=>{
    const txt = prettyJson(f.raw);
    fileMap.set(f.path,{text:txt,lines:txt.split(/\r?\n/)});
  });

  // File presence helpers
  const fileNameSet = new Set(files.map(f=>f.path.toLowerCase()));
  const hasFile = (...names)=>names.some(n=>{
    const needle=n.toLowerCase();
    for(const fp of fileNameSet){
      if(fp.endsWith('/'+needle)||fp.endsWith(needle)) return true;
    }
    return false;
  });

  // Pattern catalogs
  const PAT = {
    ccf: [
      {key:'dcrConfig', re:/\"dcrConfig\"\s*:/i},
      {key:'connectorUiConfig', re:/\"connectorUiConfig\"\s*:/i},
      {key:'connectorUIConfig', re:/\"connectorUIConfig\"\s*:/i},
      {key:'restApiPoller', re:/restapipoller|api\s*polling|poller[-_]config/i},
      {key:'dcrResource', re:/microsoft\.insights\/datacollectionrules/i},
      {key:'dceResource', re:/microsoft\.insights\/datacollectionendpoints/i},
      {key:'graphQueries', re:/\"graphQueries\"\s*:/i},
      {key:'streamsKey', re:/\"streams\"\s*:/i}
    ],
    http: [
      {key:'workspaceId', re:/workspaceid|customerid|la_workspace_id/i},
      {key:'sharedKey', re:/sharedkey|workspacekey|primarykey/i},
      {key:'apiLogs', re:/\/api\/logs(\?|")/i},
      {key:'xMsSignature', re:/x-ms-signature|authorization:\s*sharedkey/i},
      {key:'logAnalyticsUri', re:/loganalyticsuri/i},
      {key:'odsHost', re:/(ods|opinsights)\.azure\.(com|cn|us|de|gov)/i},
      {key:'logTypeHeader', re:/log-type/i},
      {key:'xMsDateHeader', re:/x-ms-date/i}
    ],
    legacy: [
      {key:'cefKeyword', re:/\bCEF\b/i},
      {key:'syslogTable', re:/\bSyslog\b/i},
      {key:'commonSecurityLog', re:/\bCommonSecurityLog\b/i},
      {key:'amaKeyword', re:/Azure\s+Monitor\s+Agent|AMA\b/i},
      {key:'agentInstall', re:/install.*(cef|agent)/i}
    ]
  };

  // Findings with line numbers
  const findings=[];
  function scanFile(path){
    const fo=fileMap.get(path); if(!fo) return;
    function collect(side, patt){
      const {text,lines}=fo;
      const re=new RegExp(patt.re.source,patt.re.flags.includes('g')?patt.re.flags:patt.re.flags+'g');
      let m;
      while((m=re.exec(text))!==null){
        const lineNum = text.slice(0,m.index).split(/\r?\n/).length;
        const lineTxt = lines[lineNum-1]?.trim().slice(0,180)||'';
        findings.push({side,pattern:patt.key,file:path,line:lineNum,lineText:lineTxt});
        if(m.index===re.lastIndex) re.lastIndex++;
      }
    }
    PAT.ccf.forEach(p=>collect('CCF',p));
    PAT.http.forEach(p=>collect('HTTP',p));
    PAT.legacy.forEach(p=>collect('LEGACY',p));
  }
  files.forEach(f=>scanFile(f.path));

  // Per-connector evaluation
  const connectorAnalyses=[];
  const connectors = (art.connectors||[]).map(c=>{
    const raw=c.raw||{};
    const txt=JSON.stringify(raw).toLowerCase();
    const hasDcrConfig=!!raw?.properties?.dcrConfig;
    const hasUiConfig=!!(raw?.properties?.connectorUiConfig||raw?.properties?.connectorUIConfig);
    const dataTypes=Array.isArray(raw?.properties?.dataTypes)?raw.properties.dataTypes:[];
    const graphQueries=Array.isArray(raw?.properties?.graphQueries)?raw.properties.graphQueries:[];
    const poller=/restapipoller|api\s*polling|poller[-_]config/.test(txt);
    const wsId=/workspaceid|customerid|la_workspace_id/.test(txt);
    const shared=/sharedkey|workspacekey|primarykey/.test(txt);
    const sig=/x-ms-signature|authorization:\s*sharedkey/.test(txt);
    const apiLogs=/\/api\/logs(\?|")/.test(txt);
    const opi=/(ods|opinsights)\.azure\.(com|cn|us|de|gov)/.test(txt)||/loganalyticsuri/.test(txt);

    const ccfStrong = [];
    if(hasDcrConfig) ccfStrong.push('dcrConfig');
    if(hasUiConfig) ccfStrong.push('uiConfig');
    if(poller) ccfStrong.push('apiPoller');
    if(graphQueries.length && hasUiConfig && hasDcrConfig && dataTypes.length) ccfStrong.push('codeless-full');

    const httpStrong=[];
    if(wsId && shared && (sig||apiLogs||opi)) httpStrong.push('workspaceId+sharedKey+endpoint/signature');
    if(sig) httpStrong.push('signature');
    if(apiLogs) httpStrong.push('/api/logs');
    if(opi && !httpStrong.includes('/api/logs')) httpStrong.push('opinsights');

    connectorAnalyses.push({
      id:c.id,
      ccfStrong,
      httpStrong
    });

    return {
      id:c.id,
      ccfScore:ccfStrong.length,
      httpScore:httpStrong.length
    };
  });

  // Core resource scanning
  const coreFiles = Array.isArray(art.coreFiles)?art.coreFiles:[];
  let coreHasDcr=false,coreHasDce=false,coreHasApiLogs=false,coreHasWorkspaceCreds=false;
  coreFiles.forEach(cf=>{
    const txt=prettyJson(cf.raw);
    if(/microsoft\.insights\/datacollectionrules/i.test(txt)) coreHasDcr=true;
    if(/microsoft\.insights\/datacollectionendpoints/i.test(txt)) coreHasDce=true;
    if(/\/api\/logs(\?|")/i.test(txt)) coreHasApiLogs=true;
    if(/workspaceid/i.test(txt)&&/(sharedkey|workspacekey|primarykey)/i.test(txt)) coreHasWorkspaceCreds=true;
  });

  // Derived counts
  const totalCcf = connectors.reduce((s,c)=>s+c.ccfScore,0);
  const totalHttp= connectors.reduce((s,c)=>s+c.httpScore,0);

  // Legacy signal presence (global)
  const legacyMatches = findings.filter(f=>f.side==='LEGACY').map(f=>f.pattern);
  const legacyUnique = [...new Set(legacyMatches)];

  const hasStrongCcfAnchor = coreHasDcr || hasFile('dcr.json','connectorDefinition.json','pollerConfig.json') ||
    connectors.some(c=>c.ccfScore>0);
  const hasStrongHttpAnchor = coreHasApiLogs || coreHasWorkspaceCreds ||
    connectors.some(c=>c.httpScore>0);

  // Legacy criteria: legacy signals present AND no strong CCF anchors AND no strong HTTP anchors
  const qualifiesLegacy = legacyUnique.length>0 && !hasStrongCcfAnchor && !hasStrongHttpAnchor;

  let type='Unknown';
  if(hasStrongCcfAnchor) type='CCF';
  else if(hasStrongHttpAnchor) type='HTTP Data Collector API';
  else if(qualifiesLegacy) type='Legacy (CEF/AMA)';
  else type='Unknown';

  // Fallback tie-breaker (avoid forcing CCF when neither side strong)
  if(type==='Unknown' && (totalCcf>0 || totalHttp>0)){
    if(totalCcf>totalHttp) type='CCF';
    else if(totalHttp>totalCcf) type='HTTP Data Collector API';
  }

  // Reasoning lines
  const reasoningLines=[];
  reasoningLines.push(`Final: ${type}`);
  if(coreHasDcr) reasoningLines.push('Core template resource: dataCollectionRules');
  if(coreHasDce) reasoningLines.push('Core template resource: dataCollectionEndpoints');
  if(hasFile('dcr.json')) reasoningLines.push('Packaging: dcr.json present');
  if(hasFile('connectorDefinition.json')) reasoningLines.push('Packaging: connectorDefinition.json');
  if(hasFile('pollerConfig.json')) reasoningLines.push('Packaging: pollerConfig.json');
  if(coreHasApiLogs) reasoningLines.push('Core: /api/logs flow');
  if(coreHasWorkspaceCreds) reasoningLines.push('Core: workspaceId + sharedKey pattern');
  if(legacyUnique.length) reasoningLines.push(`Legacy signals: ${legacyUnique.join(', ')}`);
  if(type==='Unknown') reasoningLines.push('No decisive CCF, HTTP, or Legacy anchors.');
  if(type==='CCF' && !coreHasDcr && !hasFile('dcr.json','connectorDefinition.json','pollerConfig.json'))
    reasoningLines.push('CCF inferred from connector patterns (no packaging artifacts).');
  if(type.startsWith('HTTP') && !coreHasApiLogs && !coreHasWorkspaceCreds)
    reasoningLines.push('HTTP inferred from connector endpoint/signature patterns (no core flow).');
  if(type.startsWith('Legacy') && legacyUnique.length)
    reasoningLines.push('Classified Legacy due to CEF/Syslog/AMA indicators without CCF or HTTP anchors.');

  // Evidence lines
  const evidenceLines=[];
  findings.forEach(f=>{
    if(f.side==='CCF') evidenceLines.push(`CCF: ${f.pattern} @ ${f.file}:${f.line}`);
    if(f.side==='HTTP') evidenceLines.push(`HTTP: ${f.pattern} @ ${f.file}:${f.line}`);
    if(f.side==='LEGACY') evidenceLines.push(`Legacy: ${f.pattern} @ ${f.file}:${f.line}`);
  });

  const counts = {
    ccf: connectors.filter(c=>c.ccfScore>0).length,
    http: connectors.filter(c=>c.httpScore>0).length,
    legacy: legacyUnique.length,
    total: connectors.length
  };

  return {
    type,
    connectors,
    counts,
    core:{
      dcrResource:coreHasDcr,
      dceResource:coreHasDce,
      httpApiLogs:coreHasApiLogs,
      workspaceKeyPair:coreHasWorkspaceCreds,
      packaging:{
        dcrJson:hasFile('dcr.json'),
        connectorDefinition:hasFile('connectorDefinition.json'),
        pollerConfig:hasFile('pollerConfig.json')
      }
    },
    reasoning:'Architecture Reasoning:\n'+reasoningLines.map(l=>'• '+l).join('\n'),
    evidence:'Signals:\n'+evidenceLines.map(l=>'• '+l).join('\n'),
    reasoningLines,
    evidenceLines,
    findings,
    signalsCatalog:{
      ccf: connectorAnalyses.map(c=>({id:c.id,strong:c.ccfStrong||[]})),
      http: connectorAnalyses.map(c=>({id:c.id,strong:c.httpStrong||[]})),
      legacy: legacyUnique,
      core: reasoningLines.filter(l=>/Packaging|Core|Legacy|inferred/i.test(l))
    },
    legacySignals: legacyUnique
  };
}

// --- Updated Solution Meta rendering focused on causes & line-level evidence ---
function updateSolutionMeta(){
  const box = document.getElementById('solutionMeta');
  if(!box) return;

  const meta = STATE.meta;
  const analysis = STATE.solutionAnalysis;
  box.innerHTML = '';

  const esc = s => escapeHtml(s||'');

  if(!analysis){
    box.textContent = 'No analysis.';
    return;
  }

  // Determine architecture badge class
  const lowerType = analysis.type.toLowerCase();
  let archClass = 'unknown';
  if(lowerType.startsWith('ccf')) archClass = 'ccf';
  else if(lowerType.startsWith('http')) archClass = 'http';
  else if(lowerType.startsWith('legacy')) archClass = 'legacy';
  else archClass = 'unknown';

  // Badge
  const archDiv = document.createElement('div');
  archDiv.className = 'arch-highlight ' + archClass;
  archDiv.textContent = analysis.type;
  box.appendChild(archDiv);

  // Solution name & publisher (if meta available)
  if(meta){
    const nameLine = document.createElement('div');
    nameLine.style.margin = '6px 0 4px';
    nameLine.innerHTML = `<b>Solution:</b> ${esc(meta.solutionName || '(unknown)')}`;
    box.appendChild(nameLine);

    if(meta.publisher){
      const pub = document.createElement('div');
      pub.innerHTML = `<b>Publisher:</b> ${esc(meta.publisher)}`;
      box.appendChild(pub);
    }

    if(Array.isArray(meta.categories) && meta.categories.length){
      const cat = document.createElement('div');
      cat.innerHTML = `<b>Categories:</b> ${esc(meta.categories.slice(0,6).join(', '))}${meta.categories.length>6?'…':''}`;
      box.appendChild(cat);
    }
    if(Array.isArray(meta.domains) && meta.domains.length){
      const dom = document.createElement('div');
      dom.innerHTML = `<b>Domains:</b> ${esc(meta.domains.slice(0,6).join(', '))}${meta.domains.length>6?'…':''}`;
      box.appendChild(dom);
    }
  }

  // Counts summary line
  const counts = analysis.counts || {};
  const countsDiv = document.createElement('div');
  countsDiv.style.margin = '8px 0 4px';
  countsDiv.style.fontSize = '.63rem';
  countsDiv.style.color = 'var(--text-dim)';
  countsDiv.innerHTML =
    `<b>Connector Signals:</b> CCF:${counts.ccf||0} | HTTP:${counts.http||0} | Legacy:${counts.legacy||0} | Total:${counts.total||0}`;
  box.appendChild(countsDiv);

  // Core / packaging summary
  const core = analysis.core || {};
  const pack = core.packaging || {};
  const coreLines = [];
  if(pack.dcrJson) coreLines.push('dcr.json');
  if(pack.connectorDefinition) coreLines.push('connectorDefinition.json');
  if(pack.pollerConfig) coreLines.push('pollerConfig.json');
  if(core.dcrResource) coreLines.push('dataCollectionRules resource');
  if(core.dceResource) coreLines.push('dataCollectionEndpoints resource');
  if(core.httpApiLogs) coreLines.push('/api/logs flow');
  if(core.workspaceKeyPair) coreLines.push('workspaceId + sharedKey');

  if(coreLines.length){
    const coreDiv = document.createElement('div');
    coreDiv.style.margin = '4px 0 4px';
    coreDiv.innerHTML = `<b>Core Signals:</b> ${esc(coreLines.join(', '))}`;
    box.appendChild(coreDiv);
  }

  // Legacy signals
  if(Array.isArray(analysis.legacySignals) && analysis.legacySignals.length){
    const legDiv = document.createElement('div');
    legDiv.style.margin = '4px 0 4px';
    legDiv.innerHTML = `<b>Legacy Indicators:</b> ${esc(analysis.legacySignals.join(', '))}`;
    box.appendChild(legDiv);
  }

  // Reasoning lines (short list)
  const reasoningWrap = document.createElement('div');
  reasoningWrap.style.margin = '6px 0 4px';
  const reasoningList = (analysis.reasoningLines||[]).slice(0,8);
  reasoningWrap.innerHTML =
    `<b>Reasoning:</b><br>` +
    reasoningList.map(l=>`<span style="display:block;">${esc(l)}</span>`).join('');
  box.appendChild(reasoningWrap);
  if((analysis.reasoningLines||[]).length > reasoningList.length){
    const more = document.createElement('div');
    more.style.fontSize = '.55rem';
    more.style.color = 'var(--text-dim)';
    more.textContent = `(+${analysis.reasoningLines.length - reasoningList.length} more)`;
    box.appendChild(more);
  }

  // Evidence summary (just counts)
  const evidCount = (analysis.findings||[]).length;
  const evidDiv = document.createElement('div');
  evidDiv.style.margin = '6px 0 4px';
  evidDiv.innerHTML = `<b>Evidence Lines:</b> ${evidCount}`;
  box.appendChild(evidDiv);

  // Button to open modal (if there is evidence)
  if(evidCount){
    const btn = document.createElement('button');
    btn.className = 'btn-muted';
    btn.style.fontSize = '.55rem';
    btn.style.padding = '4px 10px';
    btn.textContent = 'View Line-Level Evidence';
    btn.addEventListener('click', ()=>{
      if(typeof openDetectionEvidence === 'function'){
        openDetectionEvidence(analysis);
      } else {
        alert('Evidence modal not available.');
      }
    });
    box.appendChild(btn);
  }

  // Optional quick connector summary table (top 6)
  if(Array.isArray(analysis.connectors) && analysis.connectors.length){
    const tbl = document.createElement('table');
    tbl.style.marginTop = '8px';
    tbl.style.width = '100%';
    tbl.style.borderCollapse = 'collapse';
    tbl.style.fontSize = '.55rem';

    const head = document.createElement('thead');
    head.innerHTML = `<tr style="background:var(--panel-muted);">
      <th style="text-align:left;padding:3px 6px;">Connector</th>
      <th style="text-align:left;padding:3px 6px;">CCF</th>
      <th style="text-align:left;padding:3px 6px;">HTTP</th>
    </tr>`;
    tbl.appendChild(head);

    const body = document.createElement('tbody');
    analysis.connectors.slice(0,6).forEach(c=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td style="padding:3px 6px;border:1px solid var(--panel-border);">${esc(c.id)}</td>
        <td style="padding:3px 6px;border:1px solid var(--panel-border);">${c.ccfScore||0}</td>
        <td style="padding:3px 6px;border:1px solid var(--panel-border);">${c.httpScore||0}</td>`;
      body.appendChild(tr);
    });
    if(analysis.connectors.length > 6){
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="3" style="padding:3px 6px;border:1px solid var(--panel-border);color:var(--text-dim);text-align:center;">(+${analysis.connectors.length - 6} more)</td>`;
      body.appendChild(tr);
    }
    tbl.appendChild(body);
    box.appendChild(tbl);
  }

  // Footer help hint
  const hint = document.createElement('div');
  hint.style.marginTop = '8px';
  hint.style.fontSize = '.52rem';
  hint.style.color = 'var(--text-dim)';
  hint.innerHTML = 'Classification heuristic: CCF / HTTP / Legacy (CEF/AMA) / Unknown. Validate with official Sentinel docs.';
  box.appendChild(hint);
}

function openDetectionEvidence(){
  if(!STATE.solutionAnalysis?.findings?.length){
    setStatus('No line-level findings.', true);
    return;
  }
  const backdrop = document.getElementById('evidenceModalBackdrop');
  backdrop.style.display='flex';
  buildEvidenceRows();
}
function closeDetectionEvidence(){
  const backdrop = document.getElementById('evidenceModalBackdrop');
  backdrop.style.display='none';
}
function buildEvidenceRows(){
  const rowsEl = document.getElementById('evidenceRows');
  const sideFilter = document.getElementById('evidenceSideFilter').value;
  const searchVal = document.getElementById('evidenceSearch').value.trim().toLowerCase();
  const expandAll = !!rowsEl.dataset.expanded;

  const findings = STATE.solutionAnalysis.findings || [];
  const filtered = findings.filter(f=>{
    if(sideFilter!=='all' && f.side!==sideFilter) return false;
    if(searchVal){
      const hay = (f.pattern+' '+f.lineText+' '+f.file).toLowerCase();
      if(!hay.includes(searchVal)) return false;
    }
    return true;
  });

  rowsEl.innerHTML='';
  filtered.forEach(f=>{
    const div=document.createElement('div');
    div.className='evidence-row '+(f.side.toLowerCase()==='ccf'?'ccf':'http');
    const snippet = expandAll ? f.lineText : (f.lineText.length>140?f.lineText.slice(0,137)+'…':f.lineText);
    div.innerHTML = `
      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
        <code>${escapeHtml(f.file)}:${f.line}</code>
        <span style="font-weight:600;">${escapeHtml(f.side)}</span>
        <span style="color:var(--badge-text);">${escapeHtml(f.pattern)}</span>
      </div>
      <div style="margin-top:2px;color:var(--text-dim);">${escapeHtml(snippet)}</div>
    `;
    rowsEl.appendChild(div);
  });

  document.getElementById('evidenceCount').textContent = `${filtered.length} match${filtered.length!==1?'es':''}`;
}

function toggleExpandEvidence(){
  const rowsEl = document.getElementById('evidenceRows');
  rowsEl.dataset.expanded = rowsEl.dataset.expanded ? '' : '1';
  document.getElementById('evidenceExpandBtn').textContent = rowsEl.dataset.expanded ? 'Collapse' : 'Expand All';
  buildEvidenceRows();
}

function copyEvidence(){
  const sideFilter = document.getElementById('evidenceSideFilter').value;
  const searchVal = document.getElementById('evidenceSearch').value.trim().toLowerCase();
  const findings = STATE.solutionAnalysis.findings || [];
  const filtered = findings.filter(f=>{
    if(sideFilter!=='all' && f.side!==sideFilter) return false;
    if(searchVal){
      const hay = (f.pattern+' '+f.lineText+' '+f.file).toLowerCase();
      if(!hay.includes(searchVal)) return false;
    }
    return true;
  });
  const text = filtered.map(f => `${f.side}\t${f.pattern}\t${f.file}:${f.line}\t${f.lineText}`).join('\n');
  try{
    navigator.clipboard.writeText(text);
    setStatus(`Copied ${filtered.length} evidence lines.`);
  }catch{
    setStatus('Clipboard copy failed', true);
  }
}

// Wire modal events once DOM ready
document.addEventListener('DOMContentLoaded', ()=>{
  const backdrop = document.getElementById('evidenceModalBackdrop');
  if(backdrop){
    document.getElementById('evidenceCloseBtn').addEventListener('click',closeDetectionEvidence);
    document.getElementById('evidenceCloseBtn2').addEventListener('click',closeDetectionEvidence);
    document.getElementById('evidenceSideFilter').addEventListener('change',buildEvidenceRows);
    document.getElementById('evidenceSearch').addEventListener('input',buildEvidenceRows);
    document.getElementById('evidenceExpandBtn').addEventListener('click',toggleExpandEvidence);
    document.getElementById('evidenceCopyBtn').addEventListener('click',copyEvidence);
    document.addEventListener('keydown',e=>{ if(e.key==='Escape') closeDetectionEvidence(); });
    backdrop.addEventListener('click',e=>{ if(e.target===backdrop) closeDetectionEvidence(); });
  }
});



function buildDesignOverview(){
  const el=$('#designOverview');
  if(!STATE.artifacts||!STATE.meta){ el.textContent='No data.'; return; }
  const a=STATE.artifacts;
  const tableSet=new Set([
    ...a.connectors.flatMap(c=>c.tables||[]),
    ...a.dcrs.flatMap(d=>d.tables||[]),
    ...a.functions.flatMap(f=>f.tables||[])
  ]);
  const lines=[];
  function entry(label,count,desc){ lines.push(`<div><b>${label}</b> (${count}) – ${desc}</div>`); }
  entry('Data Connectors',a.connectors.length,'Ingestion integration points');
  entry('DCRs',a.dcrs.length,'Data Collection Rules');
  entry('Data Flows', a.dcrs.reduce((sum,d)=>sum+(d.flowsData?d.flowsData.length:0),0)
    + a.coreFiles.filter(c=>c.coreKind==='dcr').reduce((s,c)=>s+(c.flowsData?c.flowsData.length:0),0),'Per DCR flow nodes');
  entry('KQL Functions',a.functions.length,'Reusable logic');
  entry('Tables',tableSet.size,'Target schemas');
  entry('Analytics Rules',a.analytics.length,'Detections');
  entry('Hunting Queries',a.hunting.length,'Investigation queries');
  entry('Workbooks',a.workbooks.length,'Dashboards');
  entry('Playbooks',a.playbooks.length,'Automation');
  entry('Watchlists',a.watchlists.length,'Enrichment lists');
  entry('Notebooks',a.notebooks.length,'Advanced notebooks');
  lines.push('<hr style="border:none;border-top:1px solid var(--panel-border);margin:.4rem 0;">');
  const archType = STATE.solutionAnalysis?.type || 'Unknown';
const archClass = archType === 'CCF'
  ? 'ccf'
  : (archType.startsWith('HTTP') ? 'http' : 'unknown');
lines.push(`
  <div style="margin-top:8px;">
    <span class="arch-highlight ${archClass}">
      Architecture: ${escapeHtml(archType)}
    </span>
  </div>
`);
  el.innerHTML=lines.join('');
}

function showArtifactDetails(node){
  const div=$('#artifactMeta');
  if(!node){ div.textContent='Select a node.'; return; }
  const m=node.meta||{};
  const out=[];
  out.push(`<div style="font-weight:600;margin-bottom:2px;">${TYPE_META[node.type]?.label||node.type}</div>`);
  out.push(`<div><b>ID:</b> ${escapeHtml(node.id)}</div>`);
  if(node.type==='filecore'){
    if(m.coreKind) out.push(`<div><b>Core Kind:</b> ${escapeHtml(m.coreKind)}</div>`);
    if(m.coreKind==='dcr') out.push(`<div><b>DataFlows:</b> ${m.dataFlows||0} Streams:${m.streamCount||0}</div>`);
  }
  if(node.type==='dataflow'){
    out.push(`<div><b>Parent DCR:</b> ${escapeHtml(m.parentDcr||'')}</div>`);
    out.push(`<div><b>Streams:</b> ${escapeHtml((m.streams||[]).join(', ')||'—')}</div>`);
    if(m.outputTables?.length) out.push(`<div><b>Outputs:</b> ${escapeHtml(m.outputTables.join(', '))}</div>`);
    out.push(`<div><b>Transform:</b> ${m.hasTransform?`${m.transformLines} lines (${m.transformChars} chars)`:'None'}</div>`);
  }
  if(node.type==='connector'){
    if(m.mechanism) out.push(`<div><b>Mechanism:</b> ${escapeHtml(m.mechanism)}</div>`);
    if(m.kindCategory) out.push(`<div><b>Kind:</b> ${escapeHtml(m.kindCategory)}</div>`);
    if(m.tables?.length) out.push(`<div><b>Tables:</b> ${escapeHtml(m.tables.join(', '))}</div>`);
    if(m.streams?.length) out.push(`<div><b>Streams:</b> ${escapeHtml(m.streams.join(', '))}</div>`);
    if(m.description) out.push(`<div style="margin-top:4px;"><b>Description:</b> ${escapeHtml(m.description.slice(0,600))}${m.description.length>600?'…':''}</div>`);
  }
  if(['workbook','analyticrule','huntingquery'].includes(node.type)){
    if(m.tables?.length) out.push(`<div><b>Tables:</b> ${escapeHtml(m.tables.join(', '))}</div>`);
    if(m.severity) out.push(`<div><b>Severity:</b> ${escapeHtml(m.severity)}</div>`);
    if(m.tactics) out.push(`<div><b>Tactics:</b> ${escapeHtml(m.tactics)}</div>`);
    if(m.queryMetrics) out.push(`<div><b>Query:</b> ${m.queryMetrics.lines} lines (${m.queryMetrics.length} chars)</div>`);
  }
  if(node.type==='kqlfunction'){
    if(m.tables?.length) out.push(`<div><b>Tables:</b> ${escapeHtml(m.tables.join(', '))}</div>`);
    if(m.queryMetrics) out.push(`<div><b>KQL:</b> ${m.queryMetrics.lines} lines (${m.queryMetrics.length} chars)</div>`);
  }
  if(node.type==='playbook') out.push(`<div><b>Triggers:</b> ${m.triggers||0} | Actions: ${m.actions||0}</div>`);
  if(node.type==='notebook' && m.cellCount!=null) out.push(`<div><b>Cells:</b> ${m.cellCount}</div>`);
  if(node.type==='watchlist' && m.description) out.push(`<div><b>Description:</b> ${escapeHtml(m.description)}</div>`);
  if(m.endpoints?.length){
    out.push(`<div><b>Endpoints:</b> ${escapeHtml(m.endpoints.slice(0,12).join(', '))}${m.endpoints.length>12?'…':''}</div>`);
  }
  if(node.meta?.paths?.length){
    out.push(
      `<div style="margin-top:4px;"><b>Source Files:</b><br>` +
      node.meta.paths
        .map(p=>`<span style="display:block;">${escapeHtml(p)}</span>`)
        .join('') +
      `</div>`
    );
  }

  div.innerHTML=out.join('');
}

function updateLogicPanel(){
  const el=$('#logicPanel');
  const ui=STATE.createUiAnalysis;
  if(!ui){ el.textContent='No createUiDefinition.json'; return; }
  const imp=ui.implied||{};
  el.innerHTML=`
    <div><b>Solution Name:</b> ${escapeHtml(ui.solutionName||'(unknown)')}</div>
    ${ui.description?`<div style="margin-top:2px;">${escapeHtml(ui.description.slice(0,240))}${ui.description.length>240?'…':''}</div>`:''}
    <div style="margin-top:4px;"><b>Implied (keyword counts):</b></div>
    <div>Connectors:${imp.dataConnectors||0} Workbooks:${imp.workbooks||0} Analytics:${imp.analyticRules||0} Hunting:${imp.huntingQueries||0} Playbooks:${imp.playbooks||0}</div>
    <div>Wizard Steps (raw occurrences): ${ui.steps||0}</div>
  `;
}

/* ================= EXPLORER ================= */
let ARTIFACT_SORT={key:'type',asc:true};
function buildArtifactExplorer(){
  const body=$('#artifactTableBody'); body.innerHTML='';
  if(!STATE.artifacts) return;
  const a=STATE.artifacts;
  const list=[
    ...a.coreFiles,...a.connectors,...a.dcrs,...a.workbooks,...a.analytics,
    ...a.hunting,...a.playbooks,...a.watchlists,...a.functions,...a.notebooks,
    ...a.infra,...a.deploy,...a.others
  ].map(x=>({
    type:x.type,
    id:x.id,
    detail:(()=>{
      if(x.type==='filecore'){
        if(x.coreKind==='mainTemplate') return `Res:${x.resourceCounts?.total||0}`;
        if(x.coreKind==='createUiDefinition') return `Steps:${x.stepsCount||0}`;
        if(x.coreKind==='dcr') return `Flows:${x.dataFlows||0}`;
        if(x.coreKind==='pollerConfig') return x.schedule?`Sched:${x.schedule.slice(0,18)}`:'';
        if(x.coreKind==='solutionMetadata') return x.version||'';
        return x.coreKind||'';
      }
      if(x.type==='connector'){
        if(x.mechanism) return x.mechanism;
        if(x.domain) return x.domain;
        return x.kindCategory||'';
      }
      if(x.type==='dependency') return `Flows:${x.dataFlows||0}`;
      if(x.type==='analyticrule') return x.severity||'';
      if(x.type==='playbook') return `T:${x.triggers||0}/A:${x.actions||0}`;
      if(x.type==='kqlfunction') return x.tables?.length?`Tbl:${x.tables.length}`:'Function';
      if(x.type==='watchlist') return x.description? x.description.slice(0,18):'';
      if(x.type==='notebook') return `Cells:${x.cellCount||0}`;
      if(x.type==='deployment') return `Res:${x.resourceCount||0}`;
      if(x.type==='functioninfra') return `Bind:${x.bindingsCount||0}`;
      return '';
    })(),
    tables:(x.tables||[]).slice(0,4).join(',')
  }));
  list.sort((a,b)=>{
    const k=ARTIFACT_SORT.key;
    const av=(a[k]||'').toString().toLowerCase();
    const bv=(b[k]||'').toString().toLowerCase();
    if(av<bv) return ARTIFACT_SORT.asc?-1:1;
    if(av>bv) return ARTIFACT_SORT.asc?1:-1;
    return 0;
  });
  const frag=document.createDocumentFragment();
  list.forEach(r=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${TYPE_META[r.type]?.label||r.type}</td><td>${escapeHtml(r.id)}</td><td>${escapeHtml(r.detail||'')}</td><td>${escapeHtml(r.tables||'')}</td>`;
    tr.addEventListener('click',()=>{
      const node=STATE.fullGraph?.nodes.find(n=>n.id===r.id);
      if(node){ highlightNode(node.id); showArtifactDetails(node); }
    });
    frag.appendChild(tr);
  });
  body.appendChild(frag);
}
function applyArtifactSearch(){
  const term=$('#artifactSearch').value.trim().toLowerCase();
  $$(`#artifactTableBody tr`).forEach(tr=>{
    tr.style.display = tr.textContent.toLowerCase().includes(term)?'':'none';
  });
}
function buildArtifactTypeQuickFilters(){
  const cont=$('#artifactTypeQuick'); cont.innerHTML='';
  TYPE_ORDER.forEach(t=>{
    const btn=document.createElement('button');
    btn.className='btn-muted'; btn.style.fontSize='.55rem';
    btn.textContent=TYPE_META[t].label;
    btn.addEventListener('click',()=>{
      $('#artifactSearch').value='';
      $$(`#artifactTableBody tr`).forEach(tr=>{
        tr.style.display = tr.children[0].textContent===TYPE_META[t].label?'':'none';
      });
    });
    cont.appendChild(btn);
  });
  const all=document.createElement('button');
  all.className='btn-muted'; all.style.fontSize='.55rem';
  all.textContent='All';
  all.addEventListener('click',()=>{
    $('#artifactSearch').value='';
    $$(`#artifactTableBody tr`).forEach(tr=>tr.style.display='');
  });
  cont.appendChild(all);
}

/* ================= EXPORTS ================= */
function exportJson(){
  const obj={meta:STATE.meta,artifacts:STATE.artifacts,graph:STATE.fullGraph,solutionAnalysis:STATE.solutionAnalysis};
  const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='sentinel_graph.json'; a.click(); URL.revokeObjectURL(a.href);
}
function exportCsv(){
  if(!STATE.fullGraph) return;
  const ns=['id,type']; STATE.fullGraph.nodes.forEach(n=>ns.push(`"${n.id.replace(/"/g,'""')}","${n.type}"`));
  const ls=['source,target,edgeType']; STATE.fullGraph.links.forEach(l=>ls.push(`"${l.source}","${l.target}","${l.edgeType}"`));
  const blob=new Blob([ns.join('\n')+'\n\n'+ls.join('\n')],{type:'text/csv'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='sentinel_graph.csv'; a.click(); URL.revokeObjectURL(a.href);
}
function exportPng(){
  if(!ensureD3())return;
  const svgEl=$('#viz');
  const xml=new XMLSerializer().serializeToString(svgEl);
  const canvas=document.createElement('canvas');
  canvas.width=svgEl.clientWidth||1400; canvas.height=svgEl.clientHeight||900;
  const ctx=canvas.getContext('2d');
  const img=new Image();
  img.onload=()=>{
    ctx.fillStyle=document.documentElement.classList.contains('dark')?'#0f172a':'#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
    const link=document.createElement('a');
    link.download='sentinel_graph.png';
    link.href=canvas.toDataURL('image/png');
    link.click();
  };
  img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(xml)));
}

/* ================= FETCH & ACTIONS ================= */
async function fetchSolutionFiles(owner,repo,branch,paths,includeNonCore){
  const coreNames=new Set([
    'maintemplate.json','solutionmetadata.json','createuidefinition.json','pollerconfig.json','dcr.json',
    'tableschema.json','host.json','functionapp.json','azuredeploy.json'
  ]);
  const base=`https://raw.githubusercontent.com/${owner}/${repo}/${encodeURIComponent(branch)}/`;
  const out=[];
  for(const p of paths){
    const fileName=p.split('/').pop().toLowerCase();
    const isConnectorCandidate=/connector|dataconnector|data[-_ ]connectors/i.test(p);
    const isCore=coreNames.has(fileName)||includeNonCore||isConnectorCandidate;
    if(!isCore) continue;
    try{
      const js=await fetchJson(base+p,'artifact');
      if(js) out.push({path:p,json:js,core:coreNames.has(fileName)});
    }catch(e){
      log(`Failed fetch ${p}: ${e.message}`,true);
    }
  }
  log(`Fetched ${out.length} JSON files.`);
  return out;
}

async function handleLoadSolutions(){
  try{
    const repoStr=$('#repoInput').value.trim();
    if(!repoStr.includes('/')) return setStatus('Use owner/repo',true);
    let [owner,repo]=repoStr.split('/');
    let branch=$('#branchInput').value.trim();
    if(!branch && CONFIG.ENABLE_BRANCH_AUTODETECT){
      setStatus('Detecting branch...');
      const def=await detectDefaultBranch(owner,repo);
      if(def){ branch=def; $('#branchInput').value=def; }
    }
    if(!branch) branch='master';
    setStatus('Listing solutions...');
    toggleLoader(true,'Listing solutions...');
    const sols=await listSolutions(owner,repo,branch);
    const sel=$('#solutionSelect'); sel.innerHTML='';
    if(!sols.length){ sel.innerHTML='<option value="">(None)</option>'; return setStatus('No solutions found',true); }
    sols.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; sel.appendChild(o); });
    setStatus(`Loaded ${sols.length} solutions.`);
  }catch(e){ setStatus(e.message||'Error loading solutions',true); }
  finally{ toggleLoader(false); }
}

async function handleVisualize(){
  if(STATE.fetching) return log('Already running...');
  const repoVal=$('#repoInput').value.trim();
  const branchVal=$('#branchInput').value.trim();
  const solution=$('#solutionSelect').value.trim();
  STATE.includeNonCore=$('#includeNonCore').checked;
  if(!repoVal.includes('/')) return setStatus('owner/repo required',true);
  if(!branchVal) return setStatus('Branch required',true);
  if(!solution) return setStatus('Pick a solution',true);
  const [owner,repo]=repoVal.split('/',2);

  STATE.fetching=true;
  toggleLoader(true);
  setStatus(`Visualizing ${owner}/${repo}@${branchVal}/${solution}`);
  try{
    const paths=await listSolutionJsonPaths(owner,repo,branchVal,solution);
    if(!paths.length) return setStatus('No JSON files found',true);
    const files=await fetchSolutionFiles(owner,repo,branchVal,paths,STATE.includeNonCore);
    if(!files.length) return setStatus('No files fetched',true);
    STATE.artifacts=buildArtifacts(files);
    harvestEmbeddedArtifacts(STATE.artifacts);
     STATE.meta=await extractSolutionMeta(owner,repo,branchVal,solution,paths);
    /* STATE.solutionAnalysis = analyzeSolutionArchitecture(STATE.artifacts);*/ 
    STATE.solutionAnalysis = analyzeSolutionArchitecture(STATE.artifacts, {
  mode: 'balanced',          // 'strict' | 'lenient'
  tieBreakPreference: 'ccf'  // 'http' | 'unknown'
});
updateSolutionMeta();
    const cuid=files.find(f=>/createuidefinition\.json$/i.test(f.path));
    STATE.createUiAnalysis=cuid?analyzeCreateUiDefinition(cuid.json):null;

    const baseGraph=buildDependencyGraph(STATE.artifacts,STATE.meta.solutionName||solution);
    const archGraph=buildArchitectureGraph(STATE.artifacts,STATE.meta,STATE.solutionAnalysis);
    STATE.fullGraph=(STATE.layoutMode==='architecture')?archGraph:baseGraph;
    STATE.graph=JSON.parse(JSON.stringify(STATE.fullGraph));

    updateSolutionMeta();
    buildDesignOverview();
    updateLogicPanel();
    buildTypeFilters();
    applyFilters();
    buildArtifactExplorer();
    buildArtifactTypeQuickFilters();
    setStatus(`Done. Nodes:${STATE.fullGraph.nodes.length} Links:${STATE.fullGraph.links.length}`);
  }catch(e){
    console.error(e);
    setStatus('Visualization failed: '+(e.message||e),true);
    log('Stack: '+(e.stack||''),true);
  }finally{
    toggleLoader(false);
    STATE.fetching=false;
  }
}

function handleReset(){
  STATE.artifacts=null; STATE.meta=null; STATE.createUiAnalysis=null; STATE.solutionAnalysis=null;
  STATE.fullGraph=null; STATE.graph={nodes:[],links:[]};
  if(ensureD3()) d3.select('#zoomLayer').selectAll('*').remove();
  $('#solutionMeta').textContent='';
  $('#artifactMeta').textContent='Select a node.';
  $('#artifactTableBody').innerHTML='';
  $('#legend').innerHTML='';
  $('#filterTypes').innerHTML='';
  $('#designOverview').textContent='(Visualize to populate.)';
  setStatus('Reset complete.');
}

/* ================= INIT / EVENTS ================= */
function setDarkMode(on){
  document.documentElement.classList.toggle('dark',on);
  STATE.dark=on;
  localStorage.setItem('scv_dark',on?'1':'0');
  $('#btnDark').textContent=on?'Light':'Dark';
  buildLegend();
}

document.addEventListener('DOMContentLoaded',()=>{
  setDarkMode(localStorage.getItem('scv_dark')==='1');
  if(ensureD3()) ZOOM_CTRL=setupZoom(); else setTimeout(()=>{ if(ensureD3()) ZOOM_CTRL=setupZoom(); },600);

  $('#btnLoad').addEventListener('click',handleLoadSolutions);
  $('#btnVisualize').addEventListener('click',handleVisualize);
  $('#btnReset').addEventListener('click',handleReset);
  $('#btnDark').addEventListener('click',()=>setDarkMode(!STATE.dark));

  $('#layoutSelect').addEventListener('change',e=>{
    STATE.layoutMode=e.target.value;
    if(STATE.artifacts){
      const baseGraph=buildDependencyGraph(STATE.artifacts,STATE.meta?.solutionName||'Solution');
      const archGraph=buildArchitectureGraph(STATE.artifacts,STATE.meta,STATE.solutionAnalysis);
      STATE.fullGraph=(STATE.layoutMode==='architecture')?archGraph:baseGraph;
      applyFilters();
      updateSolutionMeta();
      buildDesignOverview();
    }
  });

  $('#degreeScaled').addEventListener('change',()=>{STATE.degreeScaled=$('#degreeScaled').checked;if(STATE.fullGraph)applyFilters();});
  $('#showEdgeLabels').addEventListener('change',()=>{STATE.showEdgeLabels=$('#showEdgeLabels').checked;if(STATE.fullGraph)applyFilters();});

  $('#btnExportJson').addEventListener('click',exportJson);
  $('#btnExportCsv').addEventListener('click',exportCsv);
  $('#btnExportPng').addEventListener('click',exportPng);
  $('#btnRecenter').addEventListener('click',()=>{ if(STATE.simulation) STATE.simulation.alpha(.45).restart(); });
  $('#btnFit').addEventListener('click',()=>fitView());
  $('#btnClearHighlight').addEventListener('click',()=>highlightNode(null));

  $('#zoomIn').addEventListener('click',()=>{
    if(!ensureD3())return;
    const t=STATE.zoom.scale(STATE.zoom.k*1.25);
    d3.select('#viz').transition().duration(260).call(ZOOM_CTRL.transform,t);
    STATE.zoom=t;
  });
  $('#zoomOut').addEventListener('click',()=>{
    if(!ensureD3())return;
    const t=STATE.zoom.scale(STATE.zoom.k*0.8);
    d3.select('#viz').transition().duration(260).call(ZOOM_CTRL.transform,t);
    STATE.zoom=t;
  });
  $('#zoomReset').addEventListener('click',()=>{
    if(!ensureD3())return;
    const t=d3.zoomIdentity;
    d3.select('#viz').transition().duration(400).call(ZOOM_CTRL.transform,t);
    STATE.zoom=t;
  });

  $('#nodeSearch').addEventListener('input',debounce(()=>{
    const v=$('#nodeSearch').value.trim().toLowerCase();
    if(!v){ highlightNode(null); return; }
    const node=STATE.graph.nodes.find(n=>n.id.toLowerCase().includes(v));
    if(node){ highlightNode(node.id); showArtifactDetails(node); }
  },220));

  $('#artifactSearch').addEventListener('input',debounce(applyArtifactSearch,180));
  $$('th[data-sort]').forEach(th=>{
    th.addEventListener('click',()=>{
      const key=th.getAttribute('data-sort');
      if(ARTIFACT_SORT.key===key) ARTIFACT_SORT.asc=!ARTIFACT_SORT.asc;
      else {ARTIFACT_SORT.key=key; ARTIFACT_SORT.asc=true;}
      buildArtifactExplorer(); applyArtifactSearch();
    });
  });

  $('#resetFilters').addEventListener('click',()=>{
    $$('[data-type-filter]').forEach(cb=>cb.checked=true);
    if(STATE.fullGraph) applyFilters();
  });

  window.addEventListener('error',e=>log('GlobalError: '+(e.message||e.error),true));
  window.addEventListener('unhandledrejection',e=>log('UnhandledRejection: '+(e.reason?.message||e.reason),true));

  setStatus('Ready. Load solutions.');
});
document.addEventListener('keydown',e=>{ if(e.key==='Escape') highlightNode(null); });
</script>
</body>
</html>